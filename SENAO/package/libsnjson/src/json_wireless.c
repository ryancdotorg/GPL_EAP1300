#include <api_common.h>
#include <api_wireless.h>
#include <variable.h>
#include <api_lan.h>
#include <api_mesh.h>
#include <wireless_tokens.h>
#include <api_response.h>
#include <api_sys.h>
//#include <integer_check.h>
#include <json_object.h>
#include <json_tokener.h>
#include <json_wireless.h>
#include <json_common.h>
#include <api_guest.h>
#include <unistd.h>
#include <api_vpn.h>

#define ACTION_POST  1
#define ACTION_GET   2
struct device_info
{
    char deviceType[8];
    int  rssi;
    char mac[32];
    char uid[16];
    char deviceName[128];
    char locationName[128];
    char meshRole[16];
    char meshController[16];
    int  tq;
    char lANIPAddress[32];
    char LANMacAddress[32];
    int  wifi_status;
    int  dev_connect_number;
    int  rootHopCount;
    int  led_status;
    char FullFwVersion[32];
    char WANMacAddress[32];
    int  NextHopRssi;
    char NextHopMac[32];
    /* mesh_group_info */
    int  MeshChannel;
    int  Threshold;
    bool Enable;
    char MacAddr[128][32];
    char LearnRssi[128][4];
    char LinkFlags[128][4];
    char LinkMacAddr[64];
    char TqVal[32];
    char Rssi[32];
    char TxRate[128][4];
    char RxRate[128][4];
    char GwMacAddr[64];
    /* mesh_group_info end*/
    MESH_GUEST_CLIENT_INFO_T gClientInfo;
};

#define TMP_CHANNELS_FILE "/tmp/channels_wifi"
#define BACKGROUND_SCAN_FILE                    "/tmp/Background_Scanning"
#define BACKGROUND_SCAN_FILE_DIR                BACKGROUND_SCAN_FILE"/"
#define SCAN_RADIO_FILE                         "/tmp/ScanRadio"
#define SCAN_RADIO_FILE_DIR                     SCAN_RADIO_FILE"/"
#define WIFI_SCAN_FILE                          "/tmp/WiFiScanData"
#define CHANUTIL_FILENAME                       "chanUtil.txt"
#define AP_LIST_FILENAME                        "ap_list.txt"
#define STA_LIST_FILENAME                       "sta_list.txt"
#define TMP_WIFI_SCAN_FILE_DIR                  WIFI_SCAN_FILE"/"
#define TMP_CHANUTIL_FILENAME                   TMP_WIFI_SCAN_FILE_DIR CHANUTIL_FILENAME
#define TMP_AP_LIST_FILENAME                    TMP_WIFI_SCAN_FILE_DIR AP_LIST_FILENAME
#define TMP_STA_LIST_FILENAME                   TMP_WIFI_SCAN_FILE_DIR STA_LIST_FILENAME


const char* wifi_dev_name[] = {
#if SUPPORT_WLAN_24G_SETTING
    "wifi0",
#endif
#if SUPPORT_WLAN_5G_SETTING
    "wifi1",
#if SUPPORT_WLAN_5G_2_SETTING
    "wifi2"
#endif
#endif
};
#if HAS_SYSEYE
#include <libseipc.h>
#include <ezjson.h>
#define SYSEYE_PATH "/tmp/syseye.unix"
extern char *__progname;
#else // HAS_SYSEYE
#if HAS_LINKMON
#include <liblmipc.h>
#endif // HAS_LINKMON
#endif // HAS_SYSEYE

#if (HAS_LINKMON) || (HAS_SYSEYE)
#include <stdio.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <libubox/uloop.h>
#include <libubox/ustream.h>
#include <libubox/utils.h>
#include <libubus.h>
#include <json/json.h>
#include <libubox/blobmsg_json.h>
struct prog_attr {
	char name[64];
	int chn_id;
};
static struct ubus_context * ctx = NULL;
static struct blob_buf b;
static const char * cli_path;
enum
{
    SCAN_CHNID,
    SCAN_POLICY_MAX,
};

static const struct blobmsg_policy scan_policy[SCAN_POLICY_MAX] = {
	[SCAN_CHNID] = {.name = "chnID", .type = BLOBMSG_TYPE_INT32},
};

static int timeout = 30;
static bool simple_output = false;

static void scanreq_prog_cb(struct ubus_request *req, int type, struct blob_attr *msg)
{
    char *str;
    if (!msg)
        return;
    str = blobmsg_format_json_indent(msg, true, simple_output ? -1 : 0);
    strcpy(req->priv, str);
    free(str);
}

static int client_ubus_call(char *func, char *method, char *data)
{
    unsigned int id;
    int ret;
    blob_buf_init(&b, 0);

    blobmsg_add_u32(&b, scan_policy[SCAN_CHNID].name, 0);

    ret = ubus_lookup_id(ctx, func, &id);
    if (ret != UBUS_STATUS_OK) {
        printf("lookup scan_prog failed\n");
        return ret;
    }
    else {
        printf("lookup scan_prog successs\n");
    }
    return ubus_invoke(ctx, id, method, b.head, scanreq_prog_cb, data, timeout * 1000);
}

static int client_ubus_init(const char *path)
{
    uloop_init();
    cli_path = path;

    ctx = ubus_connect(path);
    if (!ctx)
    {
        printf("ubus connect failed\n");
        return -1;
    }
    //printf("connected as %08x\n", ctx->local_id);
    return 0;
}
static void client_ubus_done(void)
{
    if (ctx)
        ubus_free(ctx);
}

// The /tmp/dhcp_addr file is generated by netifd/dhcp.script, check if the project's netifd implement this
int get_dhcp_status(char *status_str)
{
    FILE *fd;
    char line[64];
    int len;
    int ret = -1;
    if ((fd = fopen("/tmp/dhcp_addr" , "r")) == NULL){
        return -1;
    }
    while(fgets(line, sizeof(line), fd)!=NULL){
        if (!strncmp(line, "noip", 4) ||
            !strncmp(line, "dhcpip",5)){
            len = strlen(line);
            if (len > 0 && line[len-1] == '\n') line[len-1] = '\0';
            strcpy(status_str, line);
            ret = 0;
        }
    }
    fclose(fd);
    return ret;
}

#define check_dhcp_addr_file "/tmp/dhcp_addr"
#define NOIP_CHECKERR_UCI -1 /* UCI fail*/
#define NOIP_CHECKERR_FILE -2 /* UCI fail*/
int check_noip_status()
{
    char proto[8];
    if (api_get_string_option(NETWORK_LAN_PROTO_OPTION, proto, sizeof(proto))){

        return NOIP_CHECKERR_UCI;
    }
    if (!strcmp(proto, "static"))
        return 0;

    if  (access(check_dhcp_addr_file, F_OK) != -1){
        FILE *f;
        if ((f = fopen(check_dhcp_addr_file, "r"))!=NULL){
            char ipstat[32];
            if (fgets(ipstat , sizeof(ipstat) , f) == NULL){
                fclose(f);
                return NOIP_CHECKERR_FILE;
	    }
            fclose(f);
            //dbg("ipstat is:%s\n",ipstat);
	    if (strstr(ipstat, "noip") != NULL)
                return 1;
        }
    }
    return 0;
}

int get_if_proto(char *proto)
{
    char json_str[1024];
    const char *tmp;
    char * path = NULL;
    struct json_object *jobj;
    int len;
    if (UBUS_STATUS_OK != client_ubus_init(path))
    {
        printf("ubus connect failed!\n");
        return -1;
    }
    client_ubus_call("network.interface.lan","status", json_str);
    if ((jobj = json_tokener_parse(json_str)) == NULL){
        printf("json translate from str to obj failed!\n");
        return -1;
    }
    tmp = json_object_get_string(json_object_object_get(jobj, "proto"));
    if (tmp == NULL){
        printf("proto object not found!\n");
        return -1;
    }
    len = json_object_get_string_len(json_object_object_get(jobj, "proto"));
    strcpy(proto, tmp);

    json_object_put(jobj);
    client_ubus_done();
    return 0;
}
int get_dns_addr(char *dns_serv)
{
    char json_str[1024];
    const char *tmp;
    char * path = NULL;
    struct json_object *jobj, *tmpa, *obj_dns;
    int len;
    if (UBUS_STATUS_OK != client_ubus_init(path))
    {
        printf("ubus connect failed!\n");
        return -1;
    }
    client_ubus_call("network.interface.lan","status", json_str);
    if ((jobj = json_tokener_parse(json_str)) == NULL){
        printf("json translate from str to obj failed!\n");
        return -1;
    }

    obj_dns = json_object_object_get(jobj,"dns-server");
    if (obj_dns == NULL){
        printf("get dns_server object error!\n");
        return -1;
    }
    tmpa = json_object_array_get_idx(obj_dns,0);

//    tmp = json_object_get_string(json_object_object_get(jobj, "dns-server"));
//    if (tmp == NULL){
//        printf("dns_server object not found!\n");
//        return -1;
//    }
    if (tmpa == NULL){
        printf("get dns_server index 0 error!\n");
        return -1;
    }

    strcpy(dns_serv, json_object_get_string(tmpa));

    json_object_put(jobj);
    client_ubus_done();
    return 0;
}

int get_if_addrinfo(char *iface, uint32_t *ip, uint32_t *mask)
{
    int if_fd;
    struct ifreq ifr;
    if_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (if_fd < 0){
        perror("interface socket error:");
        return -1;
    }
    memcpy(ifr.ifr_name, iface, IF_NAMESIZE);
    if (ioctl(if_fd, SIOCGIFADDR, &ifr, sizeof(ifr)) < 0){
        perror("SIOCGIFADDR:");
        close(if_fd);
        return -1;
    }
    struct sockaddr_in *sin = (struct sockaddr_in *)&ifr.ifr_addr;
    *ip = sin->sin_addr.s_addr;
	
    if (ioctl(if_fd, SIOCGIFNETMASK, &ifr, sizeof(ifr)) < 0){
        perror("SIOCGIFNETMASK:");
        close(if_fd);
        return -1;
    }
    sin = (struct sockaddr_in *)&ifr.ifr_addr;
    *mask = sin->sin_addr.s_addr;
    close(if_fd);
    return 0;
}

int get_if_waninfo(char *iface, uint32_t *gw)
{
    FILE *fd;
    char line[128] , *p , *c, *g, *saveptr;
    int nRet=-1;
    fd = fopen("/proc/net/route" , "r");
    while(fgets(line , sizeof(line) , fd))
    {
        //debug_print(">>>> %s\n", line);
        p = strtok_r(line , " \t", &saveptr);
        c = strtok_r(NULL , " \t", &saveptr);
        g = strtok_r(NULL , " \t", &saveptr);
        if(p!=NULL && c!=NULL)
        {
            if(strcmp(c , "00000000") == 0)
            {
                strcpy(iface,p);
                if (g){
                    long ng;
                    struct in_addr addr;
                    sscanf(g, "%lx", &ng);
                    addr.s_addr=ng;
                    *gw = ng;
                    nRet=0;
                }
                break;
            }
        }
    }
    fclose(fd);
    return nRet;
}

typedef enum http_proxy_type_t {
    PROXY_NONE = 0,
    PROXY_HTTP,
    PROXY_HTTPS
}http_proxy_type_t;
int get_http_proxy_type()
{
    int proxy_type = PROXY_NONE;
    char use_profile[200];
    char comment[16];
    char option[128];
    char *delim=" ", *p;
    char *saveptr = NULL;
    memset(use_profile, 0, sizeof(use_profile));
    api_get_string_option(REDSOCKS2_ETHERNET_PROXY_USE_PROFILE, use_profile, sizeof (use_profile));
    p = strtok_r(use_profile, delim, &saveptr);
    while(p != NULL){
        if (strcmp(p, "none")){
            sprintf(option, "%s%s%s", "redsocks2.", p, ".comment");
            memset(comment, 0, sizeof(comment));
            api_get_string_option(option, comment, sizeof (comment));
            if (!strcmp(comment, "http"))
                proxy_type |= PROXY_HTTP;
            else if (!strcmp(comment, "https"))
                proxy_type |= PROXY_HTTPS;
        }
	p = strtok_r(NULL, delim, &saveptr);
    }
    return proxy_type;
}

#define	MESH_CHECKERR_UCI -1 /* UCI fail */
int check_mesh_status()
{
    char mesh_disable[4], mesh0_disable[4], mesh1_disable[4], mesh2_disable[4];
    api_get_string_option(MESH_WIFI_DISABLED_OPTION, mesh_disable, sizeof (mesh_disable));
    // dbg("mesh_disable:[%s]\n", mesh_disable);

    if (strcmp(mesh_disable, "0"))
        return 0;

    api_get_string_option(WIRELESS_WIFI_24G_MESH_DISABLED, mesh0_disable, sizeof (mesh0_disable));
    api_get_string_option(WIRELESS_WIFI_5G_MESH_DISABLED, mesh1_disable, sizeof (mesh1_disable));
    api_get_string_option(WIRELESS_WIFI_5G_2_MESH_DISABLED, mesh2_disable, sizeof (mesh2_disable));

    // dbg("mesh0_disable:[%s] mesh1_disable:[%s] mesh2_disable:[%s]\n", mesh0_disable, mesh1_disable, mesh2_disable);

    if (!strcmp(mesh0_disable, "0") || !strcmp(mesh1_disable, "0") || !strcmp(mesh2_disable, "0"))
        return 1;

    return 0;
}
#endif // HAS_SYSEYE || HAS_LINKMON

static int get_station_counts(int dev)
{
    char ifname[6] = {0}, buf[256] = {0};
    int i = 0, client_num = 0, total_client_num = 0;
    int enjet_enable = 0;

    if ( dev < 0 || dev > 2 )
    {
        return 0;
    }

#if SUPPORT_ENJET
    if ( dev == 1) 
    {
        api_get_integer_option2(&enjet_enable, "wireless.wifi%d.qboost_enable", dev);
    }

    if (enjet_enable == 1)
    {
        sys_interact(buf, sizeof(buf), "wlanconfig enjet%d list sta | tail -n +2 | wc -l", dev);
        if ( sscanf( buf, "%d", &total_client_num ) == 1)
            return total_client_num;
    }
#endif
    for (i = 0; i < 8; i++)
    {
        memset(ifname, 0, sizeof(ifname));

        if ( i == 0 )
            sprintf( ifname, "ath%d", ( dev <= 1 )? dev : 4 );
        else
            sprintf( ifname, "ath%d%d", ( dev <= 1 )? dev : 4, i );

        memset(buf, 0, sizeof(buf));
        sys_interact(buf, sizeof(buf), "wlanconfig %s list sta | tail -n +2 | wc -l", ifname);

        client_num = 0;
        if ( sscanf( buf, "%d", &client_num ) != 1 || client_num == 0 )
            continue;

        total_client_num = total_client_num + client_num;
    }

    return total_client_num;
}

int32_t check_wifix_channel(wlan_info *wlanInfo, char *wifix, int country_code, int green_mode, int ch)
{
    char channel_list[128] = {'\0'}, *pstr, cmd[128] = {'\0'}, cmd_get[128] = {'\0'}, buf[32+1] = {'\0'}, token[127+1] = {'\0'}, *val;
    int old_country = 0, htMode = 20, domain = 2, obey = 0, outdoor = 0, dfsCertified = 0, disable_band = 15, old_disable_band = 15, nochannel = 0, weather_ch = 0, old_weather_ch = 0;
#if SUPPORT_WLAN_EXTENSION_CHANNEL
    int extension = 0;
#endif
    FILE *pp;
    char *saveptr = NULL;

        strcpy(wlanInfo->delim, ",");
        sprintf(cmd, "iwpriv %s getCountryID", wifix);
        pp = popen(cmd, "r");
        if(pp == NULL )
        {
            printf("popen() error!\n");
            return false;
        }
        fgets(cmd_get, sizeof cmd_get, pp);
        pclose(pp);

        pstr = strtok_r(cmd_get, ":", &saveptr);
        pstr = strtok_r(NULL, ":", &saveptr);
        if (pstr == NULL)
                return false;

        old_country = atoi(pstr);

        //if (country_code != old_country)
        {
            if (sys_check_file_existed("/lib/wifi/RegularDomain.sh"))
            {
                memset(cmd, 0, sizeof(cmd));
#if SUPPORT_WIFI_10_2_VERSION
                sprintf(cmd, "iwpriv %s get_disable_band", wifix);
#else
                sprintf(cmd, "iwpriv %s g_disable_band", wifix);
#endif
                //printf("[%d]cmd: %s\n", __LINE__, cmd);
                pp = popen(cmd, "r");
                if(pp == NULL )
                {
                    printf("popen() error!\n");
                    return false;
                }
                memset(cmd_get, 0, sizeof(cmd_get));
                fgets(cmd_get, sizeof cmd_get, pp);
                pclose(pp);

                pstr = strtok_r(cmd_get, ":", &saveptr);
                pstr = strtok_r(NULL, ":", &saveptr);
                if (pstr == NULL)
                {
                    return false;
                }

                old_disable_band = atoi(pstr);

                if (!sys_get_regular_domain_info(&domain))
                {
                    domain = 2;
                }

                if(domain==3 && ch!=38)
                    return false;

                memset(buf, 0, sizeof (buf));
                if (sys_interact(buf, sizeof(buf), "iwpriv %s g_weather_ch | awk -F\":\" '{print $2}'", wifix) > 0)
                {
                    old_weather_ch = atoi(buf);
                }

                if (api_get_integer_option("sysProductInfo.model.outdoor", &outdoor))
                    outdoor = 0;

                memset(token, 0, sizeof(token));
                switch (domain)
                {
                    case 0:
                        snprintf(token, sizeof(token), "sysProductInfo.model.fccDfsCertified");
                        break;
                    case 1:
                        snprintf(token, sizeof(token), "sysProductInfo.model.etsiDfsCertified");
                        break;
                    default:
                        if ((country_code == 32)||(country_code == 76)||(country_code == 124)||(country_code == 152)||
                            (country_code == 170)||(country_code == 188)||(country_code == 214)||(country_code == 218)||
                            (country_code == 320)||(country_code == 340)||(country_code == 458)||(country_code == 484)||
                            (country_code == 591)||(country_code == 604)||(country_code == 630)||(country_code == 840)||
                            (country_code == 858)||(country_code == 862))
                        {
                            snprintf(token, sizeof(token), "sysProductInfo.model.fccDfsCertified");
                        }
                        else if ((country_code == 8)||(country_code == 40)||(country_code == 56)||(country_code == 100)||
                                 (country_code == 191)||(country_code == 203)||(country_code == 208)||(country_code == 233)||
                                 (country_code == 246)||(country_code == 250)||(country_code == 276)||(country_code == 300)||
                                 (country_code == 348)||(country_code == 352)||(country_code == 372)||(country_code == 380)||
                                 (country_code == 442)||(country_code == 492)||(country_code == 528)||(country_code == 578)||
                                 (country_code == 616)||(country_code == 620)||(country_code == 642)||(country_code == 643)||
                                 (country_code == 703)||(country_code == 705)||(country_code == 724)||(country_code == 752)||
                                 (country_code == 756)||(country_code == 826)||(country_code == 829)||(country_code == 830))
                        {
                            snprintf(token, sizeof(token), "sysProductInfo.model.etsiDfsCertified");
                        }
                }
                if (!strcmp(token,"") || api_get_integer_option(token, &dfsCertified))
                {
                    dfsCertified = 3;
                }
                memset(buf, 0, sizeof (buf));
                if (sys_interact(buf, sizeof(buf), "sh /lib/wifi/RegularDomain.sh %d %d %d %d %d", country_code, domain, green_mode, outdoor, dfsCertified) > 0)
                {
                    buf[strcspn(buf,"\n")] = '\0';
                    val = strtok_r(buf," ", &saveptr);
                    disable_band = atoi(val);
                    val = strtok_r(NULL, " ", &saveptr);
                    if(val != NULL){
                        weather_ch = atoi(val);
                        memset(cmd, 0, sizeof (cmd));
                        sprintf(cmd, "iwpriv %s weather_ch %d", wifix, weather_ch);
                        //printf("[%d]cmd: %s\n", __LINE__, cmd);
                        system(cmd);
                    }
#if SUPPORT_WLAN_5G_2_SETTING
                    if(wlanInfo->wifix == 1) 
                        disable_band=(disable_band & 12);
                    else if(wlanInfo->wifix == 2)
                        disable_band=(disable_band & 3);
                    if (disable_band == 0) 
                        nochannel = 1;

                    api_set_integer_option2(nochannel, "wireless.%s.nochannel", wifix);
#endif
                    if (!nochannel)
                    {
                        memset(cmd, 0, sizeof (cmd));
                        sprintf(cmd, "iwpriv %s disable_band %d", wifix, disable_band);
                        system(cmd);
                    }
                }
            }
            memset(cmd, 0, sizeof (cmd));
            sprintf(cmd, "iwpriv %s setCountryID %d", wifix, country_code);
            system(cmd);
        }

        memset(channel_list, 0, sizeof (channel_list));
        sys_get_channel_list_info(wlanInfo, channel_list, sizeof(channel_list));
#if SUPPORT_WLAN_5G_SETTING
        if (wlanInfo->wifix == 1)
        {
            if (!strcmp(channel_list, ""))
            {
                wlanInfo->htmode = 20;
                memset(channel_list, 0, sizeof (channel_list));
                sys_get_channel_list_info(wlanInfo, channel_list, sizeof(channel_list));
            }
        }
#if SUPPORT_WLAN_5G_2_SETTING
        else if (wlanInfo->wifix == 2)
        {
            if (!strcmp(channel_list, ""))
            {
                wlanInfo->htmode = 20;
                memset(channel_list, 0, sizeof (channel_list));
                sys_get_channel_list_info(wlanInfo, channel_list, sizeof(channel_list));

            }
        }
#endif
#endif
        pstr = strtok_r(channel_list, ",", &saveptr);
        while (pstr != NULL)
        {
            if ( ch == 0 || ch == atoi(pstr) )
            {
                if (country_code != old_country)
                {
                    if (sys_check_file_existed("/lib/wifi/RegularDomain.sh"))
                    {
                        memset(cmd, 0, sizeof (cmd));
                        sprintf(cmd, "iwpriv %s disable_band %d", wifix, old_disable_band);
                        system(cmd);
                        memset(cmd, 0, sizeof (cmd));
                        sprintf(cmd, "iwpriv %s weather_ch %d", wifix, old_weather_ch);
                        system(cmd);
                    }
                    memset(cmd, 0, sizeof (cmd));
                    sprintf(cmd, "iwpriv %s setCountryID %d", wifix, old_country);
                    system(cmd);
                }
                return true;
            }
            pstr = strtok_r(NULL, ",", &saveptr);
        }

        //if (country_code != old_country)
        {
            if (sys_check_file_existed("/lib/wifi/RegularDomain.sh"))
            {
                memset(cmd, 0, sizeof (cmd));
                sprintf(cmd, "iwpriv %s disable_band %d", wifix, old_disable_band);
                system(cmd);
                memset(cmd, 0, sizeof (cmd));
                sprintf(cmd, "iwpriv %s weather_ch %d", wifix, old_weather_ch);
                system(cmd);
            }
            memset(cmd, 0, sizeof (cmd));
            sprintf(cmd, "iwpriv %s setCountryID %d", wifix, old_country);
            system(cmd);
        }

        return false;
}
/*****************************************************************
* NAME: sysCheckStringOnWeb
* ---------------------------------------------------------------
* FUNCTION:
* INPUT:
* OUTPUT:
* Author:   Adonn 20070516
* Modify:   Jerry Chen 20080922
*           Yolin 20131016: support escape xml string
*           Yolin 20131107: support escape QR code wifi config str
****************************************************************/
void _sysCheckString(const char *srcStr, char *destStr, int flag)
{
    int len;
    int i;
    int cnt = 0;

    // protect
    if(!destStr)
    {
        return;
    }

    // protect
    if(srcStr == NULL || (len = strlen(srcStr))==0)
    {
        destStr[0] = '\0';
        return;
    }

    for(i=0; i<=len; i++)
    {
        switch(flag)
        {
            case 5://use in single quote format
                if(srcStr[i] == '\'')
                {
                    destStr[cnt++] = '\'';
                    destStr[cnt++] = '\"';
                    destStr[cnt++] = '\'';
                    destStr[cnt++] = '\"';
                }
                destStr[cnt++] = srcStr[i];
                break;
            case 4://support escape APP location string
                if(srcStr[i] == '\"' || srcStr[i] == '\\' || srcStr[i] == '`')/*if flag==1 means need to check single quote*/
                {
                    destStr[cnt++] = '\\';
                }
                destStr[cnt++] = srcStr[i];
                break;
            case 3://QR code escape string
                if(srcStr[i] == '\\' || srcStr[i] == ';' || srcStr[i] == ',' || srcStr[i] == ':' || srcStr[i] == '\"')
                {
                    destStr[cnt++] = '\\';
                }
                destStr[cnt++] = srcStr[i];
                break;
            case 2: //escape xml string
                switch (srcStr[i])
                {
                    case '<':
                        strcpy(&destStr[cnt++], "&lt;");
                        cnt+=3;
                        break;
                    case '>':
                        strcpy(&destStr[cnt++], "&gt;");
                        cnt+=3;
                        break;
                    case '"':
                        strcpy(&destStr[cnt++], "&quot;");
                        cnt+=5;
                        break;
                    case '\'':
                        strcpy(&destStr[cnt++], "&apos;");
                        cnt+=5;
                        break;
                    case '&':
                        strcpy(&destStr[cnt++], "&amp;");
                        cnt+=4;
                        break;
                    default:
                        destStr[cnt++] = srcStr[i];
                        break;
                }
                break;
            case 1:
            case 0:
            default:
                if(srcStr[i] == '\"' || srcStr[i] == '\\' || srcStr[i] == '`' || (flag && (srcStr[i] == '\'')))/*if flag==1 means need to check single quote*/
                {
                    destStr[cnt++] = '\\';
                }
                destStr[cnt++] = srcStr[i];
                break;
        }
    }
}

/*****************************************************************
* NAME: sysCheckStringOnWeb
* ---------------------------------------------------------------
* FUNCTION: change " \ ' to \",\\, and \'
* INPUT:
* OUTPUT:
* Author:   Jay
* Modify:
****************************************************************/
void sysCheckStringOnWeb(const char *srcStr, char *destStr)
{
        _sysCheckString(srcStr,destStr,1);
}

void sysCheckStringOnApp(const char *srcStr, char *destStr)
{
        _sysCheckString(srcStr,destStr,4);
}

/*****************************************************************
* NAME:    is_mesh_function_enabled
* ---------------------------------------------------------------
* FUNCTION:
* INPUT:
* OUTPUT:
* Author:
* Modify:
******************************************************************/
bool is_mesh_function_enabled()
{
	int mesh24g_disabled=0,mesh5g_disabled=0;
#if HAS_WLAN_5G_2_SETTING
	int mesh5g_2_disabled=0;
#endif
	api_get_wifi_mesh_disabled_option(WIRELESS_WIFI_MESH_DISABLED_OPTION, &mesh24g_disabled);
	api_get_wifi_mesh_disabled_option(WIRELESS_WIFI_5G_MESH_DISABLED_OPTION, &mesh5g_disabled);
#if HAS_WLAN_5G_2_SETTING
	api_get_wifi_mesh_disabled_option("wireless.wifi2_mesh.disabled", &mesh5g_2_disabled);
#endif
	if (!mesh24g_disabled || !mesh5g_disabled
#if HAS_WLAN_5G_2_SETTING
	|| !mesh5g_2_disabled
#endif
	)
		return TRUE;
	return FALSE;
}

/*****************************************************************
* NAME:    get_json_string_from_query
* ---------------------------------------------------------------
* FUNCTION:
* INPUT:
* OUTPUT:
* Author:
* Modify:
******************************************************************/
int get_json_string_from_query(char *query_str, char *outbuf, char *string_name)
{
    struct json_object *jobj, *jobj_string;
    int ret = 0;

    if(NULL != query_str)
    {
        if((jobj = json_tokener_parse(query_str)))
        {
            if((jobj_string = json_object_object_get(jobj, string_name)))
            {
                ret = 1;
                sprintf(outbuf, "%s", json_object_get_string(jobj_string));
                printf("%s: %s = %s\n", __FUNCTION__, string_name, outbuf);
                /* Free obj */
                json_object_put(jobj_string);
            }
            else
            {
                printf("%s: Can't get string %s!\n", __FUNCTION__, string_name);
                ret = -1;
            }
            /* Free obj */
            json_object_put(jobj);
        }
    }
    else
    {
        printf("$s: NULL == query_str!\n", __FUNCTION__);
        ret = -1;
    }

    return ret;
}

/*****************************************************************
* NAME:    check_mesh_global_ipv6
* ---------------------------------------------------------------
* FUNCTION:
* INPUT:
* OUTPUT:
* Author:
* Modify:
******************************************************************/
bool check_mesh_global_ipv6(char *target_ip)
{
    bool result;
    char buf[128];
    char *ptr;
    char *saveptr = NULL;

    result = FALSE;

    memset(buf, 0x00, sizeof(buf));
    sys_interact(buf, sizeof(buf),
            "ifconfig %s | grep \"inet6 addr: fc00\" | awk \'/Scope:Global/{print $3}\' | awk -F \"/\" \'{print $1}\'", BRG_DEV);

    ptr = strtok_r(buf, "\n", &saveptr);

    if (ptr != NULL && target_ip != NULL)
    {
        do
        {
            if(0 == strcasecmp(ptr, target_ip))
            {
                result = TRUE;
                break;
            }
        } while(NULL != (ptr = strtok_r(NULL, "\n", &saveptr)));
    }

    return result;
}

/*****************************************************************
* NAME:    is_throughput_test_in_process
* ---------------------------------------------------------------
* FUNCTION:
* INPUT:
* OUTPUT:
* Author:
* Modify:
******************************************************************/
bool is_throughput_test_in_process()
{
    bool result;
    char *ptr;
    char buf[256];

    result = FALSE;
    memset(buf, 0x00, sizeof(buf));

#if 0
    /* 1348 root       1556 R   iperf3 -6 -c fe80::8adc:96ff:fe17:4965%br-lan -i 2 -t 10 -w 256k -P 4 -p 60001 */
    sysutil_interact(buf, sizeof(buf), "ps -w | awk '/iperf3/{print $14}'");

    ptr = buf;

    while(NULL != (ptr = strchr(ptr, '\n')))
    {
        ptr++;

        if(strstr(ptr, "256k"))
        {
            result = TRUE;
            break;
        }
    }
#else
    sys_interact(buf, sizeof(buf), "ps -w | grep \"iperf3\" |  grep \"256k\" | grep -v \"grep\"");

    if(strlen(buf)) {
        result = TRUE;
    }
#endif

    return result;
}

/*****************************************************************
* NAME:    run_throughput_test_cb
* ---------------------------------------------------------------
* FUNCTION:
* INPUT:
* OUTPUT:
* Author:
* Modify:
******************************************************************/
int run_throughput_test_cb(ResponseEntry *rep, char *query_str)
{
    char destination[32];
    char buf[64]={0};
    char buf2[4]={0};
    int port;
    char ptr[128], ptr2[32] = "iperf3 -6 -c ", ptr3[32] = " -i 2 -t 10 -w 256k -P 4 -p ", ptr4[32] = " > /tmp/throughput_result &";
    ResponseStatus *res = rep->res;

    memset(destination, 0x00, sizeof(destination));

    if(is_throughput_test_in_process())
    {
        RET_GEN_ERRORMSG(res, API_PROCESSING, "PROCESSING");
    }
    else
    {
        if(sys_check_file_existed("/tmp/throughput_result"))
        {
            system("rm -f /tmp/throughput_result");
        }

        if(get_json_string_from_query(query_str, destination, "dst_mac_addr"))
        {
            sys_interact(buf2, sizeof(buf2), "[ $(echo %s | grep -E \"^[a-fA-F0-9:]{17}$\") ] && echo -n 1 || echo -n 0", destination);
            if(atoi(buf2))
            {
                sys_interact(buf, sizeof(buf), "/sbin/mesh.sh mac_to_ipv6_unique_local %s | tr -d '\\n'", destination);
            }
            else
            {
                sprintf(buf, "%s", destination);
            }
            api_get_integer_option("iperf3.iperf3.server_port", &port);

            sprintf(ptr, "%s%s%s%d%s", ptr2, buf, ptr3, port, ptr4);
            system(ptr);

            RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
        }
    }
}

/*****************************************************************
* NAME:    redirect_to_target_mesh
* ---------------------------------------------------------------
* FUNCTION:
* INPUT:
* OUTPUT:
* Author:
* Modify:
******************************************************************/
int redirect_to_target_mesh(ResponseEntry *rep, char *query_str, char *target_ip, struct json_object *jobj, int flag)
{
    char buf_payload[1024], buf_result[1024], buf[1024];
    char mesh_name[32], mesh_pwd[32], source[32], destination[32], body[64], upload[16], download[16];
    ResponseStatus *res = rep->res;

    memset(buf_payload, 0, sizeof(buf_payload));
    memset(buf_result, 0, sizeof(buf_result));
    memset(buf, 0, sizeof(buf));

    sys_interact(buf, sizeof(buf),"cat /etc/config/wireless | grep Mesh_id | awk -F'id' 'NR==1 { print $2 }'");
    sscanf(buf, " '%[^']", mesh_name);
    sys_interact(buf, sizeof(buf),"cat /etc/config/wireless | grep aeskey' ' | awk -F'aeskey' 'NR==1 { print $2 }'");
    sscanf(buf, " '%[^']", mesh_pwd);

    if (flag == ACTION_POST)
    {
        get_json_string_from_query(query_str, source, "target_mac_addr");
        get_json_string_from_query(query_str, destination, "dst_mac_addr");

        sprintf(buf, "%s%s%s%s%s%s%s%s%s%s", "{\"MeshAdminUsername\":\"", mesh_name, "\",\"MeshAdminPassword\":\"", mesh_pwd, "\",\"", "Destination\":\"", destination, "\",\"Source\":\"", source, "\"}");
        sysCheckStringOnApp(buf, buf_payload);
        sys_interact(buf_result, sizeof(buf_result),"app_client -i %s -m POST -a mesh/%s -e 1 -p \"%s\"", target_ip, "RunMeshThroughputTest", buf_payload);
        sscanf(buf_result, "%*[^:]: \"%[^\"]", buf);

        if (strcmp(buf,"ERROR_PROCESS_IS_RUNNING")==0)
        {
            RET_GEN_ERRORMSG(res, API_PROCESSING, "PROCESSING");
        }
    }
    else if(flag == ACTION_GET)
    {
        sscanf(query_str, "{%[^}]", body);
        sprintf(buf, "%s%s%s%s%s%s%s", "{\"MeshAdminUsername\":\"", mesh_name, "\",\"MeshAdminPassword\":\"", mesh_pwd, "\",", body, "}");
        sysCheckStringOnApp(buf, buf_payload);
        sys_interact(buf_result, sizeof(buf_result),"app_client -i %s -m POST -a mesh/%s -e 1 -p \"%s\"", target_ip, "GetMeshThroughputTestResult", buf_payload);
        sscanf(buf_result, "%*[^:]: \"%[^\"]", buf);

        if (strcmp(buf,"OK")==0)
        {
            sscanf(buf_result, "%*[^,],%*[^:]: \"%[^\\]", buf);
            sprintf(upload, "%s%s", buf, "/sec");
            sscanf(buf_result, "%*[^,],%*[^,],%*[^:]: \"%[^\\]", buf);
            sprintf(download, "%s%s", buf, "/sec");
        }
        json_object_object_add(jobj, "Upload", json_object_new_string(upload));
        json_object_object_add(jobj, "Download", json_object_new_string(download));
    }
    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_get_wireless_radio(ResponseEntry *rep, struct json_object *jobj, char *radio){

    int val = 0, ch = 0, extch =0, txpower = 0, climit = 0, minbrate = 0, rssi = 0, country_code = 0, regular = 0, max_ctry_num = 0, obey = 0, mode = 0, htmode_len = 0, hwmode_deny = 0, ch_enable = 0, ch_dynamic_enable = 0;
    int disabled = 0, radio_idx = 0, i = 0, outdoor_distance = 0, enjet_enable = 0, ap_time_slot = 0, priority_num = 0, ch_config_interval = 0;
    bool enable = false, green_mode = 0, ax_mode_disable = 0;
    char *p, hwmode[8]={0}, htmode[8]={0}, opmode[16] = {0}, *wifix, country[21]={0}, section[32]={0}, sta_connect_ssid[32]={0}, role[10]={0}, priority[10]={0}, sta_channel[10]={0}, sta_htmode[32]={0}, ch_list[128]={0} ;
    char cur_htmode[8]={0};
    char ifname[128]={0};
    int cur_channel = 0;
    int country_id = 0;
    struct json_object *jobj_sta;
    struct json_object *jobj_enjet;
    struct json_object *jobj_ap_role;
    struct json_object *jobj_sta_role;

    ResponseStatus *res = rep->res;

    jobj_sta = json_object_new_object();
    jobj_enjet = json_object_new_object();
    jobj_ap_role = json_object_new_object();
    jobj_sta_role = json_object_new_object();

    country_code_t *countryTablePtr = NULL;

    if(NULL == jobj)
    {
        RET_GEN_ERRORMSG(res, API_INVALID_DATA_TYPE, "JSON");
    }

    if (strcmp(radio, WIFI_RADIO_NAME_24G) == 0)
    {
        wifix="wifi0";
        radio_idx=0 ;
    }
    else if (strcmp(radio, WIFI_RADIO_NAME_5G) == 0)
    {
        wifix="wifi1";
        radio_idx=1;
    }
    else if (strcmp(radio, WIFI_RADIO_NAME_5G_2) == 0)
    {
        wifix="wifi2";
        radio_idx=2;
    }

    /* opmode */
    api_get_integer_option2(&climit, "wireless.%s.clientlimits_enable", wifix);
    if ( climit )
        api_get_integer_option2(&climit, "wireless.%s.clientlimits_number", wifix);

    api_get_string_option2(opmode, sizeof(opmode), "wireless.%s.opmode", wifix);

    if (strcmp(radio, WIFI_RADIO_NAME_24G) == 0)
    {
        if (strcmp(opmode, "sta_ap") == 0)
        {
            sys_interact(ifname, sizeof(ifname), "ls /sys/class/net/ | grep -E \"^ath29\" | head -1");
        }
        else
        {
            sys_interact(ifname, sizeof(ifname), "ls /sys/class/net/ | grep -E \"^ath0|^ath2|^enjet0|^mgmt0|^dummy0\" | head -1");
        }
    }
    else if (strcmp(radio, WIFI_RADIO_NAME_5G) == 0)
    {
        if (strcmp(opmode, "sta_ap") == 0)
        {
            sys_interact(ifname, sizeof(ifname), "ls /sys/class/net/ | grep -E \"^ath59\" | head -1");
        }
        else
        {
            sys_interact(ifname, sizeof(ifname), "ls /sys/class/net/ | grep -E \"^ath1|^ath5|^enjet1|^mgmt1|^dummy1\" | head -1");
        }
    }
    else if (strcmp(radio, WIFI_RADIO_NAME_5G_2) == 0)
    {
        if (strcmp(opmode, "sta_ap") == 0)
        {
            sys_interact(ifname, sizeof(ifname), "ls /sys/class/net/ | grep -E \"^ath69\" | head -1");
        }
        else
        {
            sys_interact(ifname, sizeof(ifname), "ls /sys/class/net/ | grep -E \"^ath4|^ath6|^dummy2\" | head -1");
        }
    }

    ifname[strcspn(ifname,"\n")] = '\0';

    //for ( p = opmode; *p; ++p) *p = toupper(*p);
    if (strcmp(opmode, "ap") == 0) 
        mode = OPM_AP;
    else if (strcmp(opmode, "sta") == 0)
        mode = OPM_CB;
    else if (strcmp(opmode, "wds_ap") == 0)
        mode = OPM_WDSAP;
    else if (strcmp(opmode, "wds_bridge") == 0)
        mode = OPM_WDSB;
    else if (strcmp(opmode, "wds_sta") == 0)
        mode = OPM_WDSSTA;
    else if (strcmp(opmode, "sta_ap") == 0)
        mode = OPM_RP;
#if SUPPORT_SCANNING_RADIO_MODE
    else if (strcmp(opmode, "mon") == 0)
    {
        mode = OPM_SCAN;
        strcpy(opmode, "scan");
    }
#endif
    /* enable */
    if(api_get_wifix_section_name(mode, radio_idx, section))
    {
        RET_GEN_ERRORMSG(res, API_INTERNAL_ERROR, "GET SECTION NAME");
    }

    for (i = 0; i < AP_WIFI_IFACE_NUM; i++)
    {
        api_get_wifi_ifacex_disabled_option_by_sectionname(mode, section, i+1, &disabled);
        if (!disabled)
        {
            enable = true;
            break;
        }
    }

    /* country */
    api_get_integer_option2(&country_code, "wireless.%s.country", wifix);
    if (sys_get_regular_domain_info(&regular))
    {
        switch (regular)
        {
            case REG_FCC:
                countryTablePtr = FCC_CountryCodeTable;
                max_ctry_num = sizeof(FCC_CountryCodeTable) / sizeof(country_code_t);
                break;
            case REG_ETSI:
                countryTablePtr = ETSI_CountryCodeTable;
                max_ctry_num = sizeof(ETSI_CountryCodeTable) / sizeof(country_code_t);
                break;
            default:
                countryTablePtr = INT_CountryCodeTable;
                max_ctry_num = sizeof(INT_CountryCodeTable) / sizeof(country_code_t);
                break;
        }
    }
    for (i = 0; i < max_ctry_num; i++)
    {
        if ( countryTablePtr[i].code == country_code ) 
        {
            snprintf(country, sizeof(country), "%s", countryTablePtr[i].name);
            country_id = countryTablePtr[i].code;
            break;
        }
    }
    /* green_mode */
    api_get_integer_option2(&obey, "wireless.%s.obeyregpower", wifix);
    green_mode=(obey == 1?true:false);
    /* hwmode */
    api_get_string_option2(hwmode, sizeof(hwmode), "wireless.%s.hwmode", wifix);
    /* ax_mode_disable */
    if(wifix == "wifi0"){
        ax_mode_disable = ((strcmp(hwmode, "11axg") == 0) ? false:true);
    }
    else if(wifix == "wifi1"){
        ax_mode_disable = ((strcmp(hwmode, "11axa") == 0) ? false:true);
    }
    /* legacy_hwmode_deny */
    api_get_integer_option2(&hwmode_deny, "wireless.%s.legacy_hwmode_deny", wifix);
    /* htmode */
    api_get_string_option2(htmode, sizeof(htmode), "wireless.%s.htmode", wifix);
    /* channel */
    api_get_integer_option2(&ch, "wireless.%s.channel", wifix);

    if ( strcmp(opmode, "ap") == 0 )
    {
        /* channel_config_enable */
        api_get_integer_option2(&ch_enable, "wireless.%s.channel_config_enable", wifix);
        if (ch_enable==1)
        {
            /* channel_config_list */
            api_get_string_option2(ch_list, sizeof(ch_list), "wireless.%s.channel_config_list", wifix);
        }
#if SUPPORT_WATCHGUARD_FUNCTION
        api_get_integer_option2(&ch_dynamic_enable, "wireless.%s.channel_config_dynamic", wifix);
        api_get_integer_option2(&ch_config_interval, "wireless.%s.channel_config_interval", wifix);
#endif
    }

    sys_interact(sta_channel, sizeof(sta_channel), "iwlist %s chan |grep Current |awk '{printf $2}'", ifname);
    cur_channel = atoi(sta_channel);

    if ( strcmp(opmode, "sta") == 0 || strcmp(opmode, "sta_ap") == 0 || strcmp(opmode, "wds_sta") == 0 )
    {
        sys_interact(sta_htmode, sizeof(sta_htmode), "wlanconfig %s list |tail -n +2 |awk '{printf $18}'", ifname);
        if ( strlen(sta_htmode) != 0) 
        {
            htmode_len = strlen(sta_htmode);
            strncpy(cur_htmode, sta_htmode+(htmode_len-4),4);
        }
        else
        {
            sys_interact(sta_htmode, sizeof(sta_htmode), "iw %s info |grep channel |awk '{printf $6}'", ifname);
            if (strlen(sta_htmode) == 0)
            {
                strcpy(cur_htmode, "N/A");
                // cur_channel = 0;
            }
            else
            {
                snprintf(cur_htmode, sizeof(cur_htmode), "%s%s", "HT", sta_htmode);
            }
        }
    }
    else
    {
        strcpy(cur_htmode, htmode);
    }

    /* ext_channel */
    api_get_integer_option2(&extch, "wireless.%s.ext_channel", wifix);
    /* txpower */
    api_get_integer_option2(&txpower, "wireless.%s.txpower", wifix);

    /* client limit */
    api_get_integer_option2(&climit, "wireless.%s.clientlimits_enable", wifix);
    if ( climit )
        api_get_integer_option2(&climit, "wireless.%s.clientlimits_number", wifix);
    /* Min Rate */
    api_get_integer_option2(&minbrate, "wireless.%s.min_rate", wifix);
    /* RSSI */
    
    api_get_integer_option2(&rssi, "wireless.%s.fasthandover_status", wifix);
    if ( rssi == 1 )
        api_get_integer_option2(&rssi, "wireless.%s.fasthandover_rssi", wifix);
     
    /* distance */
    api_get_integer_option2(&outdoor_distance, "wireless.%s.distance", wifix);
    outdoor_distance = (outdoor_distance/1000);
    /* dfs_backup_channel */

    json_object_object_add(jobj, "enable", json_object_new_boolean(enable));
    json_object_object_add(jobj, "country", json_object_new_string(country));
    json_object_object_add(jobj, "country_id", json_object_new_int(country_id));
    json_object_object_add(jobj, "green_mode", json_object_new_boolean(green_mode));
    json_object_object_add(jobj, "cur_channel", json_object_new_int(cur_channel));
    json_object_object_add(jobj, "cur_ht_mode", json_object_new_string(cur_htmode));
    json_object_object_add(jobj, "channel", json_object_new_int(ch));
    if ( strcmp(opmode, "ap") == 0 )
    {
        json_object_object_add(jobj, "channel_config_enable", json_object_new_boolean(ch_enable));
        if (ch_enable==1)
        {
            json_object_object_add(jobj, "channel_config_list", json_object_new_string(ch_list));
        }
#if SUPPORT_WATCHGUARD_FUNCTION
        json_object_object_add(jobj, "channel_config_dynamic", json_object_new_boolean(ch_dynamic_enable));
        json_object_object_add(jobj, "channel_config_interval", json_object_new_int(ch_config_interval));
#endif
    }
    //if (strcmp(radio, WIFI_RADIO_NAME_24G) == 0)
        //json_object_object_add(jobj, "ext_channel", json_object_new_int(extch));
    json_object_object_add(jobj, "hw_mode", json_object_new_string(hwmode));
#if HWMODE_AX
    json_object_object_add(jobj, "is_11ax_disable", json_object_new_boolean(ax_mode_disable));
#endif
    json_object_object_add(jobj, "ht_mode", json_object_new_string(htmode));
    json_object_object_add(jobj, "tx_power", json_object_new_int(txpower));
    json_object_object_add(jobj, "client_limit", json_object_new_int(climit));
    json_object_object_add(jobj, "min_bitrate", json_object_new_int(minbrate));
    json_object_object_add(jobj, "rssi_threshold", json_object_new_int(rssi));
    json_object_object_add(jobj, "opmode", json_object_new_string(opmode));

    if ( strcmp(opmode, "sta") == 0 || strcmp(opmode, "sta_ap") == 0 || strcmp(opmode, "wds_sta") == 0 )
    {
        sys_interact(sta_connect_ssid, sizeof(sta_connect_ssid), "iwconfig %s |grep ESSID|awk -F '\"' {'printf $2'}", ifname);
        json_object_object_add(jobj_sta, "connect_to_ssid", json_object_new_string(sta_connect_ssid));
        json_object_object_add(jobj, "STA_mode_stat", jobj_sta);
    }
    json_object_object_add(jobj, "distance", json_object_new_int(outdoor_distance));
    json_object_object_add(jobj, "is_legacy_hwmode_deny", json_object_new_boolean(hwmode_deny));
    if (strcmp(radio, WIFI_RADIO_NAME_5G) == 0 || strcmp(radio, WIFI_RADIO_NAME_5G_2) == 0)
        json_object_object_add(jobj, "dfs_backup_channel", json_object_new_string("---"));

#if SUPPORT_ENJET
    api_get_integer_option2(&enjet_enable, "wireless.%s.qboost_enable", wifix);
    api_get_integer_option2(&ap_time_slot, "wireless.%s.aptimeslot", wifix);
    api_get_integer_option2(&priority_num, "wireless.%s.stationpriority", wifix);
    if (priority_num == 0) 
    {
        strcpy(priority,"High");
    }
    else if (priority_num == 1)
    {
        strcpy(priority,"Middle");
    }
    else
    {
        strcpy(priority,"Low");
    }

    if ( mode == OPM_AP || mode == OPM_WDSAP) 
    {
        strcpy(role,"AP_role");
    }
    else
    {
        strcpy(role,"Station_role");
    }
    json_object_object_add(jobj, "enjet_enable", json_object_new_boolean(enjet_enable));
    json_object_object_add(jobj_ap_role, "ap_time_slot", json_object_new_int(ap_time_slot));
    json_object_object_add(jobj_sta_role, "priority", json_object_new_string(priority));
    json_object_object_add(jobj_enjet, "role", json_object_new_string(role));
    json_object_object_add(jobj_enjet, "AP_role", jobj_ap_role);
    json_object_object_add(jobj_enjet, "Station_role", jobj_sta_role);
    json_object_object_add(jobj, "enjet", jobj_enjet);
#endif
    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_set_login(ResponseEntry *rep, struct json_object *jobj, char *token){
    ResponseStatus *res = rep->res;
    json_object_object_add(jobj, "token", json_object_new_string(token));
    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_set_wireless_radio(ResponseEntry *rep, char *query_str, char *radio)
{
    char *opmode = NULL, *hwmode = NULL, *htmode = NULL, *wifix, *p, section[32]={0}, *country = NULL;
    char opmode_opt[64]={0}, *enjet_info=NULL, *priority=NULL, *ap_role=NULL, *sta_role=NULL;
    int i = 0, radio_idx = 0, mode = 0, ch = 0, ext_ch = 0, txpower = 0, climit = 0, climitNum = 0, minbrate = 0, rssi = 0, ext_ch_set = 0, disabled = 0, ch_config_interval = 0;
    int tmp_status = 0, encryption = 0, hwmode_val = 0, regular = 0, country_code = 0, max_ctry_num = 0, htMode = 0, outdoor_distance;
    bool enable = 0, green_mode = 0, enjet_enable = 0, hwmode_deny = 0, ax_mode_disable = 0, ch_enable = 0, ch_dynamic_enable = 0;
    char *ch_list=NULL, *p_ch, *ch_ptr=NULL, buf_ch[128]={0};
    int array_str_num = 0, ssid_num = 0;
    struct json_object *jobj = NULL, *jobj_enjet = NULL, *jobj_enjet_ap = NULL, *jobj_enjet_sta = NULL;
    int ap_time_slot = 0, priority_num = 0;
    int txpower_start = 8, txpower_end = 28;
    int outdoor = 0;
    int country_id = 0;

    country_code_t *countryTablePtr = NULL;
    wlan_info wlanInfo;
    ResponseStatus *res = rep->res;
    const int extch_array[] = {36,44,52,60,100,108,116,124,132,140,149,157};
    size_t extch_array_str_num = (sizeof extch_array) / (sizeof *extch_array);
    memset(&wlanInfo, 0, sizeof(wlanInfo));

    if(NULL != query_str)
    {
        if((jobj = jsonTokenerParseFromStack(rep, query_str)))
        {
            senao_json_object_get_boolean(jobj, "enable", &enable);
            senao_json_object_get_and_create_string(rep, jobj, "country", &country);
            senao_json_object_get_boolean(jobj, "green_mode", &green_mode);
            senao_json_object_get_boolean(jobj, "is_11ax_disable", &ax_mode_disable);
            senao_json_object_get_and_create_string(rep, jobj, "opmode", &opmode);
            senao_json_object_get_and_create_string(rep, jobj, "ht_mode", &htmode);
            senao_json_object_get_integer(jobj, "channel",&(ch));
            senao_json_object_get_boolean(jobj, "channel_config_enable", &ch_enable);
            senao_json_object_get_and_create_string(rep, jobj, "channel_config_list", &ch_list);
#if SUPPORT_WATCHGUARD_FUNCTION
            senao_json_object_get_boolean(jobj, "channel_config_dynamic", &ch_dynamic_enable);
            senao_json_object_get_integer(jobj, "channel_config_interval",&(ch_config_interval));
#endif
            senao_json_object_get_integer(jobj, "ext_channel",&(ext_ch));
            senao_json_object_get_integer(jobj, "tx_power",&(txpower));
            senao_json_object_get_integer(jobj, "client_limit",&(climitNum));
            senao_json_object_get_integer(jobj, "min_bitrate",&(minbrate));
            //senao_json_object_get_integer(jobj, "rssi_threshold",&(rssi));
            senao_json_object_get_integer(jobj, "distance",&(outdoor_distance));
            senao_json_object_get_boolean(jobj, "is_legacy_hwmode_deny",&(hwmode_deny));
            senao_json_object_get_boolean(jobj, "enjet_enable",&(enjet_enable));
            senao_json_object_get_and_create_string(rep, jobj, "enjet", &enjet_info);
        }
        else
        {
            RET_GEN_ERRORMSG(res, API_INVALID_DATA_TYPE, "JSON");
        }
    }
    else
    {
        RET_GEN_ERRORMSG(res, API_INVALID_DATA_TYPE, "JSON");
    }
    if (enable == true) 
    {
        for (p = opmode; *p; ++p) *p = tolower(*p);

        if (strcmp(opmode, "ap") == 0) 
            mode = OPM_AP;
        else if (strcmp(opmode, "sta") == 0)
            mode = OPM_CB;
        else if (strcmp(opmode, "wds_ap") == 0)
            mode = OPM_WDSAP;
        else if (strcmp(opmode, "wds_bridge") == 0)
            mode = OPM_WDSB;
        else if (strcmp(opmode, "wds_sta") == 0)
            mode = OPM_WDSSTA;
        else if (strcmp(opmode, "sta_ap") == 0)
            mode = OPM_RP;
#if SUPPORT_SCANNING_RADIO_MODE
        else if (strcmp(opmode, "scan") == 0)
            mode = OPM_SCAN;
#endif

        for ( p = htmode; *p; ++p) *p = toupper(*p);
        if (strcmp(htmode, "HT20") == 0)
            htMode = BANDWIDTH_20MHZ, wlanInfo.htmode = 20;
        else if (strcmp(htmode, "HT40") == 0)
            htMode = BANDWIDTH_40MHZ, wlanInfo.htmode = 40;
        else if (strcmp(htmode, "HT20_40") == 0)
            htMode = BANDWIDTH_20MHZ_40MHZ, wlanInfo.htmode = 40;
        else if (strcmp(htmode, "HT80") == 0)
            htMode = BANDWIDTH_80MHZ, wlanInfo.htmode = 80;
        else
            RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);

#if SUPPORT_WLAN_EXTENSION_CHANNEL
        wlanInfo.extchan = ext_ch;
#endif
        
        if (strcmp(radio, WIFI_RADIO_NAME_24G) == 0){
            wifix="wifi0", wlanInfo.wifix=0;
            if (!(minbrate == 1 || minbrate == 2 || minbrate == 5 || minbrate == 6 || minbrate == 9 || minbrate == 11 || minbrate == 12 || minbrate == 18 || minbrate == 24))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "MINIMUN RATE");

            ext_ch_set = 1;

            if (!(txpower == 0 || (txpower >= txpower_start && txpower <= txpower_end)))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "TXPOWER");
        }
#if SUPPORT_WLAN_5G_SETTING
        else if (strcmp(radio, WIFI_RADIO_NAME_5G) == 0){
            wifix="wifi1", wlanInfo.wifix=1;
            if (!(minbrate == 6 || minbrate == 9 || minbrate == 12 || minbrate == 18 || minbrate == 24))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "MINIMUN RATE");
#if SUPPORT_WLAN_5G_2_SETTING
            if (!(ch >= 100 && ch <= 165 || ch == 0))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "CHANNEL");
#else
            if (!(ch >= 36 && ch <= 165 || ch == 0))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "CHANNEL");
#endif
            if (!(txpower == 0 || (txpower >= txpower_start && txpower <= txpower_end)))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "TXPOWER");
        }
        else if (strcmp(radio, WIFI_RADIO_NAME_5G_2) == 0){
            wifix="wifi2", wlanInfo.wifix=2;
            if (!(minbrate == 6 || minbrate == 9 || minbrate == 12 || minbrate == 18 || minbrate == 24))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "MINIMUN RATE");
            if (!(ch >= 36 && ch <= 64 || ch == 0))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "CHANNEL");

            if (!(txpower == 0 || (txpower >= txpower_start && txpower <= txpower_end)))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "TXPOWER");
        }
#endif
        else
            RET_GEN_ERRORMSG(res, API_UNKNOWN_ACTION, NULL);

        if(api_get_wifix_section_name(mode, wlanInfo.wifix, section))
        {
            RET_GEN_ERRORMSG(res, API_INTERNAL_ERROR, "GET SECTION NAME");
        }

        /* enable */
        if (mode != OPM_RP)
        {
            if (mode == OPM_WDSAP)
            {
                ssid_num = WDSAP_AP_WIFI_IFACE_NUM;
            }
            else if (mode == OPM_AP)
            {
                ssid_num = AP_WIFI_IFACE_NUM;
            }
            else
            {
                ssid_num = 1;
            }
            for (i = 0; i < ssid_num; i++)
            {
                if (api_get_wifi_ifacex_disabled_option_by_sectionname(mode, section, i+1, &disabled))
                {
                    RET_GEN_ERRORMSG(res, API_INTERNAL_ERROR, "GET IFACE DISABLED");
                }
                if ((enable == false) && (disabled == 0))
                {
                    if (api_set_wifi_ifacex_status_option_by_sectionname(mode, section, i+1, disabled?0:1))
                    {
                        RET_GEN_ERRORMSG(res, API_INTERNAL_ERROR, "SET IFACE STATUS");
                    }
                    if (api_set_wifi_ifacex_disabled_option_by_sectionname(mode, section, i+1, 1))
                    {
                        RET_GEN_ERRORMSG(res, API_INTERNAL_ERROR, "SET IFACE DISABLED");
                    }
                }
                else if ((enable == true) && (disabled == 1))
                {
                    if (api_get_wifi_ifacex_status_option_by_sectionname(mode, section, i+1, &tmp_status))
                        tmp_status = 0; 
                    if (api_set_wifi_ifacex_disabled_option_by_sectionname(mode, section, i+1, tmp_status?0:1))
                    {
                        RET_GEN_ERRORMSG(res, API_INTERNAL_ERROR, "GET IFACE DISABLED");
                    }
                    if (api_set_wifi_ifacex_status_option_by_sectionname(mode, section, i+1, 0))
                    {
                        RET_GEN_ERRORMSG(res, API_INTERNAL_ERROR, "SET IFACE STATUS");
                    }
                }
            }
        }
        /* country */
        if (sys_get_regular_domain_info(&regular))
        {
            // Get country code
            switch (regular)
            {
                case REG_FCC:
                    countryTablePtr = FCC_CountryCodeTable;
                    max_ctry_num = sizeof(FCC_CountryCodeTable) / sizeof(country_code_t);
                    break;
                case REG_ETSI:
                    countryTablePtr = ETSI_CountryCodeTable;
                    max_ctry_num = sizeof(ETSI_CountryCodeTable) / sizeof(country_code_t);
                    break;
                default:
                    countryTablePtr = INT_CountryCodeTable;
                    max_ctry_num = sizeof(INT_CountryCodeTable) / sizeof(country_code_t);
                    break;
            }
        }
        
        country_id = atoi(country);
        //debug_print("====country:%s====country_id:%d=============\n", country, country_id);

        // Ukraine : outdoor and green_mode on not support
        if (strcmp(country, "Ukraine")==0 || country_id==804)
        {
            if (api_get_integer_option("sysProductInfo.model.outdoor", &outdoor))
                outdoor = 0;
            if (green_mode==true && outdoor==1)
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "COUNTRY");
        }

        for (i = 0; i < max_ctry_num; i++)
        {
            if (strcmp(countryTablePtr[i].name, country)==0 || countryTablePtr[i].code==country_id)
            {
                country_code = countryTablePtr[i].code;
                api_set_integer_option("wireless.wifi0.country", country_code);
                api_set_integer_option("wireless.wifi1.country", country_code);
#if SUPPORT_WLAN_5G_2_SETTING
                api_set_integer_option("wireless.wifi2.country", country_code);
#endif
            }
        }

        if( country_code == 0 )
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "COUNTRY");
        
        wlanInfo.ch = ch;

        if (!check_wifix_channel(&wlanInfo, wifix, country_code, green_mode, ch))
        {
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "CHANNEL");
            wlanInfo.ch = 0;
        }

        /* green_mode */
#if 0//SUPPORT_CHANNEL_CONFIG_SETTING
        if (!api_set_wifix_channel_config_status(radio_idx, CHANNEL_CONFIG_ALL, 0, NULL, 0))
#endif
        {
            if (wlanInfo.wifix == 0)
                api_set_integer_option2(green_mode, "wireless.%s.obeyregpower", wifix);
            else
            {
                api_set_integer_option2(green_mode, "wireless.wifi1.obeyregpower");
#if SUPPORT_WLAN_5G_2_SETTING
                api_set_integer_option2(green_mode, "wireless.wifi2.obeyregpower");
#endif
            }
        }

#if HWMODE_AX
        if(wifix == "wifi0"){
            api_set_wifi_hwmode_option(WIRELESS_WIFI_HWMODE_OPTION, ax_mode_disable?P24G_IEEE802_11NG:P24G_IEEE802_11AX);
        }
        else if(wifix == "wifi1"){
            api_set_wifi_5g_hwmode_option(WIRELESS_WIFI_5G_HWMODE_OPTION, ax_mode_disable?P5G_IEEE802_11AC:P5G_IEEE802_11AX);
        }
#endif

#if SUPPORT_ENJET

        api_set_integer_option2(enjet_enable, "wireless.%s.qboost_enable", wifix);
        api_set_integer_option2(!enjet_enable, "wireless.%s_enjet.disabled", wifix);
        if (enjet_enable == true) 
        {
            api_set_lan_stp_status_option(NETWORK_LAN_STP_STATUS_OPTION, 1);
            if (jobj_enjet = jsonTokenerParseFromStack(rep, enjet_info))
            {
                senao_json_object_get_and_create_string(rep, jobj_enjet, "AP_role", &ap_role);
                senao_json_object_get_and_create_string(rep, jobj_enjet, "Station_role", &sta_role);

                if (strcmp(opmode, "ap") == 0 || strcmp(opmode, "wds_ap") == 0) 
                {
                    if (jobj_enjet_ap = jsonTokenerParseFromStack(rep, ap_role))
                    {
                        senao_json_object_get_integer(jobj_enjet_ap, "ap_time_slot",&(ap_time_slot));
                        if (ap_time_slot >=0 && ap_time_slot <=7 && ap_time_slot !=1) 
                        {
                            api_set_integer_option2(ap_time_slot, "wireless.%s.aptimeslot", wifix);
                        }
                        else
                        {
                            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "AP_TIME_SLOT");
                        }
                    }
                }
                else if (strcmp(opmode, "sta") == 0 || strcmp(opmode, "wds_sta") == 0) 
                {
                    if(jobj_enjet_sta = jsonTokenerParseFromStack(rep, sta_role))
                    {
                        senao_json_object_get_and_create_string(rep,jobj_enjet_sta, "priority", &priority);

                        if (strcmp(priority,"High") == 0) 
                        {
                            priority_num = 0;
                        }
                        else if (strcmp(priority,"Middle") == 0)
                        {
                            priority_num = 1;
                        }
                        else if (strcmp(priority,"Low") == 0)
                        {
                            priority_num = 2;
                        }
                        else
                        {
                            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "PRIORITY");
                        }
                        api_set_integer_option2(priority_num, "wireless.%s.stationpriority", wifix);
                    }
                }
            }
        }
        else
#endif
        { // enjet not support client limit
            /* Client Limits: */
            if (mode == OPM_AP || mode == OPM_WDSAP)
            {
                if (climitNum > 0 && climitNum < 128)
                {
                    climit = 1;
                    api_set_integer_option2(climitNum, "wireless.%s.clientlimits_number", wifix);
                }
                else if ( climitNum == 0 )
                    climit = 0;
                else
                    RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "CLIENT LIMITS");
                    //debug_msg("Client Limits: value is out of range [1 - 127]");
                api_set_integer_option2(climit, "wireless.%s.clientlimits_enable", wifix);
            }
        }

        /* htmode */
        if ( wlanInfo.htmode == 20 && htMode != BANDWIDTH_20MHZ) 
        {
            htMode = BANDWIDTH_20MHZ;
            snprintf(htmode, sizeof(htmode), "HT20");
        }

        if (strcmp(radio, WIFI_RADIO_NAME_24G) == 0)
        {
            if(htMode < BANDWIDTH_20MHZ || htMode > BANDWIDTH_20MHZ_40MHZ)
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "HTMODE");
        }
        else if (strcmp(radio, WIFI_RADIO_NAME_5G) == 0 || strcmp(radio, WIFI_RADIO_NAME_5G_2) == 0)
        {
            ;
        }
        if (mode != OPM_CB && mode != OPM_WDSSTA && mode != OPM_RP)
        {
            api_set_string_option2(htmode, sizeof(htmode), "wireless.%s.htmode", wifix);
        }

        if (mode == OPM_AP || mode == OPM_WDSAP)
        {
            api_set_integer_option2(hwmode_deny, "wireless.%s.legacy_hwmode_deny", wifix);
        }
        else if (hwmode_deny == 1)
        {
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "LEGACY_HWMODE_DENY");
        }

#if SUPPORT_WLAN_EXTENSION_CHANNEL
        /* ext_channel */
        if (ext_ch_set && (htMode == BANDWIDTH_20MHZ || htMode == BANDWIDTH_20MHZ_40MHZ))
        {
            if (ext_ch >= 0 && ext_ch <= 1) 
                api_set_integer_option2(ext_ch, "wireless.%s.ext_channel", wifix);
        }
#endif

        /* channel */
#if SUPPORT_WLAN_EXTENSION_CHANNEL
        if (strcmp(radio, WIFI_RADIO_NAME_5G) == 0 || strcmp(radio, WIFI_RADIO_NAME_5G_2) == 0)
        {
            api_set_integer_option2(1, "wireless.%s.ext_channel", wifix);
            for (i=0; i<extch_array_str_num; ++i){
                if (extch_array[i]==wlanInfo.ch){
                    api_set_integer_option2(0, "wireless.%s.ext_channel", wifix);
                    break;
                }
            }
        }
#endif
        if ((mode == OPM_WDSB || mode == OPM_WDSAP) && ch == 0)
        {
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "CHANNEL");
        }
        if (mode != OPM_CB && mode != OPM_WDSSTA && mode != OPM_RP) 
        {
            (wlanInfo.ch) ? api_set_integer_option2(wlanInfo.ch, "wireless.%s.channel", wifix) : api_set_string_option2("auto", sizeof("auto"), "wireless.%s.channel", wifix);
            api_set_integer_option2((wlanInfo.ch)?4:1, "wireless.%s.channel_config_status", wifix);
        }

        // channel_config_enable
        if (ch_enable==1 && mode!=OPM_AP)
        {
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "CHANNEL_CONFIG_ENABLE");
        }
        if (ch_enable==1)
        {
            if (strlen(ch_list)>0)
            {
                sys_interact(buf_ch, sizeof(buf_ch), "echo %s | grep -o \",\" | wc -l", ch_list);
                if (atoi(buf_ch) < 1)
                {
                    RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "CHANNEL_CONFIG_LIST");
                }
                memset(buf_ch, 0, sizeof (buf_ch));
                sys_interact(buf_ch, sizeof(buf_ch), "echo %s | tr -d \" \"", ch_list);
                if (buf_ch[strlen(buf_ch)-1] == '\n')
                    buf_ch[strlen(buf_ch)-1] = '\0';
                sprintf(ch_list, "%s", buf_ch);
                p_ch = strtok_r(buf_ch, ",", &ch_ptr);
                while (p_ch != NULL)
                {
                    wlanInfo.ch = atoi(p_ch);
                    if (!check_wifix_channel(&wlanInfo, wifix, country_code, green_mode, atoi(p_ch)))
                    {
                        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "CHANNEL_CONFIG_LIST");
                        wlanInfo.ch = 0;
                    }
                    p_ch = strtok_r(NULL, ",", &ch_ptr);
                }
            }
            else
            {
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "CHANNEL_CONFIG_LIST");
            }
            api_set_string_option2("auto", sizeof("auto"), "wireless.%s.channel", wifix);
            api_set_string_option2(ch_list, sizeof(ch_list), "wireless.%s.channel_config_list", wifix);
            api_set_integer_option2(4, "wireless.%s.channel_config_status", wifix);
        }
        api_set_integer_option2(ch_enable, "wireless.%s.channel_config_enable", wifix);
#if SUPPORT_WATCHGUARD_FUNCTION
        api_set_integer_option2(ch_dynamic_enable, "wireless.%s.channel_config_dynamic", wifix);
        api_set_integer_option2(ch_config_interval, "wireless.%s.channel_config_interval", wifix);
#endif

        /* opmode */
        array_str_num = (sizeof opmode_mapping) / (sizeof *opmode_mapping);
        for ( i = 0 ; i < array_str_num ; i++ )
        {
            if ( strcmp(opmode, opmode_mapping[i])==0 )
            {
                int opmodeResult=0;
                snprintf(opmode_opt, sizeof(opmode_opt), "wireless.%s.opmode", wifix);
                opmodeResult=api_set_wifi_opmode_option(opmode_opt, i);
                if(opmodeResult > 0)
                    RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "OPMODE");
                break;
            }
        }

        /* txpower */
        if (!green_mode)
        {
            api_get_integer_option("functionlist.vendorlist.TXPOWER_MIN_5G", &txpower_start);
            api_get_integer_option("functionlist.vendorlist.TXPOWER_MAX_5G", &txpower_end);

            if ((txpower < txpower_start) && (txpower != 0))
                txpower = txpower_start ;
            if (txpower > txpower_end)
                txpower = txpower_end;

#if SUPPORT_NETGEAR_FUNCTION
            if (sys_check_file_existed("/tmp/insight_im_app"))
                system("touch /etc/insight/.im_tx_power");
#endif

            api_set_integer_option2(txpower, "wireless.%s.txpower", wifix);
        }

        /* Min Rate*/
        api_set_integer_option2(minbrate, "wireless.%s.min_rate", wifix);

        /* rssi */
    /*
        if (mode == OPM_AP || mode == OPM_WDSAP){
            if (rssi <= -60 && rssi >= -100)
            {
                api_set_integer_option2(1, "wireless.%s.fasthandover_status", wifix);
                api_set_integer_option2(rssi, "wireless.%s.fasthandover_rssi", wifix);
            }
            else if ( rssi == 0 )
            {
                api_set_integer_option2(0, "wireless.%s.fasthandover_status", wifix);
            }
            else
            {
                //debug_msg("RSSI: value is out of range [-100 - -60]");
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "RSSI");
            }
        }
     */
#if SUPPORT_NETGEAR_FUNCTION
        if (sys_check_file_existed("/tmp/insight_im_app"))
        {
            system("touch /etc/insight/.im_distance");
            system("rm /tmp/insight_im_app");
        }
#endif
        outdoor_distance = (outdoor_distance*1000);
        api_set_integer_option2(outdoor_distance, "wireless.%s.distance", wifix);

    }
    else
    {
        if (strcmp(radio, WIFI_RADIO_NAME_24G) == 0){
            wifix="wifi0", wlanInfo.wifix=0;
        }
#if SUPPORT_WLAN_5G_SETTING
        else if (strcmp(radio, WIFI_RADIO_NAME_5G) == 0){
            wifix="wifi1", wlanInfo.wifix=1;
        }
        else if (strcmp(radio, WIFI_RADIO_NAME_5G_2) == 0){
            wifix="wifi2", wlanInfo.wifix=2;
        }
#endif
        else
            RET_GEN_ERRORMSG(res, API_UNKNOWN_ACTION, NULL);
        char opmode_tmp[10] ={0};
        api_get_string_option2(opmode_tmp, sizeof(opmode_tmp), "wireless.%s.opmode", wifix);

        if (strcmp(opmode_tmp, "ap") == 0)
            mode = OPM_AP;
        else if (strcmp(opmode_tmp, "sta") == 0)
            mode = OPM_CB;
        else if (strcmp(opmode_tmp, "wds_ap") == 0)
            mode = OPM_WDSAP;
        else if (strcmp(opmode_tmp, "wds_bridge") == 0)
            mode = OPM_WDSB;
        else if (strcmp(opmode_tmp, "wds_sta") == 0)
            mode = OPM_WDSSTA;
        else if (strcmp(opmode_tmp, "sta_ap") == 0)
            mode = OPM_RP;

        if(api_get_wifix_section_name(mode, wlanInfo.wifix, section))
        {
            RET_GEN_ERRORMSG(res, API_INTERNAL_ERROR, "GET SECTION NAME");
        }

        /* enable */
        if (mode == OPM_WDSAP)
        {
            ssid_num = WDSAP_AP_WIFI_IFACE_NUM;
        }
        else if (mode == OPM_AP)
        {
            ssid_num = AP_WIFI_IFACE_NUM;
        }
        else
        {
            ssid_num = 1;
        }
        for (i = 0; i < ssid_num; i++)
        {
            if (api_get_wifi_ifacex_disabled_option_by_sectionname(mode, section, i+1, &disabled))
            {
                RET_GEN_ERRORMSG(res, API_INTERNAL_ERROR, "GET IFACE DISABLED");
            }
            if ((enable == false) && (disabled == 0))
            {
                if (api_set_wifi_ifacex_status_option_by_sectionname(mode, section, i+1, disabled?0:1))
                {
                    RET_GEN_ERRORMSG(res, API_INTERNAL_ERROR, "SET IFACE STATUS");
                }
                if (api_set_wifi_ifacex_disabled_option_by_sectionname(mode, section, i+1, 1))
                {
                    RET_GEN_ERRORMSG(res, API_INTERNAL_ERROR, "SET IFACE DISABLED");
                }
            }
            else if ((enable == true) && (disabled == 1))
            {
                if (api_get_wifi_ifacex_status_option_by_sectionname(mode, section, i+1, &tmp_status))
                    tmp_status = 0; 
                if (api_set_wifi_ifacex_disabled_option_by_sectionname(mode, section, i+1, tmp_status?0:1))
                {
                    RET_GEN_ERRORMSG(res, API_INTERNAL_ERROR, "GET IFACE DISABLED");
                }
                if (api_set_wifi_ifacex_status_option_by_sectionname(mode, section, i+1, 0))
                {
                    RET_GEN_ERRORMSG(res, API_INTERNAL_ERROR, "SET IFACE STATUS");
                }
            }
        }

    }
    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}


int json_get_mesh(ResponseEntry *rep, struct json_object *jobj){

    int enable = 0, band24g = 0, band5g = 0, band5g_2 = 0, mesh_rssi = 0;
    char *radio, mesh_id[16]={0}, mesh_pw[64]={0};
    ResponseStatus *res = rep->res;

    /* enable */
    api_get_mesh_disabled_option(MESH_WIFI_DISABLED_OPTION, &enable);

    /* wifi_radio */
    api_get_wifi_mesh_disabled_option(WIRELESS_WIFI_MESH_DISABLED_OPTION, &band24g);
    api_get_wifi_mesh_disabled_option(WIRELESS_WIFI_5G_MESH_DISABLED_OPTION, &band5g);
#if SUPPORT_WLAN_5G_2_SETTING
    api_get_wifi_mesh_disabled_option(WIRELESS_WIFI_5G_2_MESH_DISABLED_OPTION, &band5g_2);
#endif

    if(band24g==0)
        radio=WIFI_RADIO_NAME_24G;
    if(band5g==0)
        radio=WIFI_RADIO_NAME_5G;
#if SUPPORT_WLAN_5G_2_SETTING
    if(band5g_2==0)
        radio=WIFI_RADIO_NAME_5G_2;
#endif

    /* mesh_id */
    api_get_wifi_mesh_id_option(WIRELESS_WIFI_MESH_ID_OPTION , mesh_id, sizeof(mesh_id));

    /* mesh_pw */
    api_get_wifi_mesh_wpa_key_option(WIRELESS_WIFI_MESH_AESKEY_OPTION , mesh_pw, sizeof(mesh_pw));

    /* mesh_rssi */
    api_get_integer_option(WIRELESS_WIFI_MESH_MESHSQTLIMITRSSI_OPTION, &mesh_rssi);

    json_object_object_add(jobj, "enable", json_object_new_boolean(!enable));
    json_object_object_add(jobj, "wifi_radio", json_object_new_string(radio));
    json_object_object_add(jobj, "mesh_id", json_object_new_string(mesh_id));
    json_object_object_add(jobj, "mesh_pw", json_object_new_string(mesh_pw));
    json_object_object_add(jobj, "mesh_rssi", json_object_new_int(mesh_rssi));

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_set_mesh(ResponseEntry *rep, char *query_str){

    char *p, *radio=NULL, *mesh_id=NULL, *mesh_pw=NULL;
    int mesh_rssi = 0;
    bool enable = 0;
    ResponseStatus *res = rep->res;

    struct json_object *jobj;
    if(NULL != query_str)
    {
        if((jobj = jsonTokenerParseFromStack(rep, query_str)))
        {
            senao_json_object_get_boolean(jobj, "enable", &enable);
            senao_json_object_get_and_create_string(rep, jobj, "wifi_radio", &radio);
            senao_json_object_get_and_create_string(rep, jobj, "mesh_id", &mesh_id);
            senao_json_object_get_and_create_string(rep, jobj, "mesh_pw", &mesh_pw);
            senao_json_object_get_integer(jobj, "mesh_rssi",&(mesh_rssi));
        }
    }

    /* enable */
    api_set_mesh_disabled_option(MESH_WIFI_DISABLED_OPTION, !enable);

    /* wifi_radio */
    for ( p = radio; *p; ++p) *p = toupper(*p);
#if SUPPORT_WLAN_5G_2_SETTING
    if (strstr(radio,WIFI_RADIO_NAME_24G))
    {
        api_set_wifi_mesh_disabled_option(WIRELESS_WIFI_MESH_DISABLED_OPTION, 0);
        api_set_wifi_mesh_disabled_option(WIRELESS_WIFI_5G_MESH_DISABLED_OPTION, 1);
        api_set_wifi_mesh_disabled_option(WIRELESS_WIFI_5G_2_MESH_DISABLED_OPTION, 1);
    }
    else if (strstr(radio,WIFI_RADIO_NAME_5G))
    {
        api_set_wifi_mesh_disabled_option(WIRELESS_WIFI_MESH_DISABLED_OPTION, 1);
        api_set_wifi_mesh_disabled_option(WIRELESS_WIFI_5G_MESH_DISABLED_OPTION, 0);
        api_set_wifi_mesh_disabled_option(WIRELESS_WIFI_5G_2_MESH_DISABLED_OPTION, 1);
    }
    else if (strstr(radio,WIFI_RADIO_NAME_5G_2))
    {
        api_set_wifi_mesh_disabled_option(WIRELESS_WIFI_MESH_DISABLED_OPTION, 1);
        api_set_wifi_mesh_disabled_option(WIRELESS_WIFI_5G_MESH_DISABLED_OPTION, 1);
        api_set_wifi_mesh_disabled_option(WIRELESS_WIFI_5G_2_MESH_DISABLED_OPTION, 0);
    }
#else
    if (strstr(radio,WIFI_RADIO_NAME_24G))
    {
        api_set_wifi_mesh_disabled_option(WIRELESS_WIFI_MESH_DISABLED_OPTION, 0);
        api_set_wifi_mesh_disabled_option(WIRELESS_WIFI_5G_MESH_DISABLED_OPTION, 1);
    }
    else if (strstr(radio,WIFI_RADIO_NAME_5G))
    {
        api_set_wifi_mesh_disabled_option(WIRELESS_WIFI_MESH_DISABLED_OPTION, 1);
        api_set_wifi_mesh_disabled_option(WIRELESS_WIFI_5G_MESH_DISABLED_OPTION, 0);
    }
#endif
    else
        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "RADIO");

    /* mesh_id */
    api_set_wifi_mesh_id_option(WIRELESS_WIFI_MESH_ID_OPTION , mesh_id, sizeof(mesh_id));
    api_set_wifi_mesh_id_option(WIRELESS_WIFI_5G_MESH_ID_OPTION , mesh_id, sizeof(mesh_id));
    api_set_wifi_mesh_id_option(WIRELESS_WIFI_5G_2_MESH_ID_OPTION , mesh_id, sizeof(mesh_id));

    /* mesh_pw */
    api_set_wifi_mesh_wpa_key_option(WIRELESS_WIFI_MESH_AESKEY_OPTION , mesh_pw, sizeof(mesh_pw));
    api_set_wifi_mesh_wpa_key_option(WIRELESS_WIFI_5G_MESH_AESKEY_OPTION , mesh_pw, sizeof(mesh_pw));
    api_set_wifi_mesh_wpa_key_option(WIRELESS_WIFI_5G_2_MESH_AESKEY_OPTION , mesh_pw, sizeof(mesh_pw));

    /* mesh_rssi */
    if (mesh_rssi <= -75 && mesh_rssi >= -95)
    {
        api_set_integer_option(WIRELESS_WIFI_MESH_MESHSQTLIMITRSSI_OPTION, mesh_rssi);
        api_set_integer_option(WIRELESS_WIFI_5G_MESH_MESHSQTLIMITRSSI_OPTION, mesh_rssi);
        api_set_integer_option(WIRELESS_WIFI_5G_2_MESH_MESHSQTLIMITRSSI_OPTION, mesh_rssi);
    }
    else
    {
        printf("RSSI: value is out of range [-95 - -75]");
        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "RSSI");
    }

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_get_mesh_info(ResponseEntry *rep, struct json_object *jobj){

    bool enable = 0;
    int wifix = 0, mesh_channel = 0, mesh_num = 0, threshold = 0;
    char mesh_disable[10]={0}, mesh_role[32]={0}, buf[18]={0}, ifname[10]={0}, mac_addr[18]={0}, learn_rssi[5]={0}, link_flags[5]={0};
    char *pch, *pch2, *pch3, *pch4, *saveptr1, *saveptr2, *saveptr3, *saveptr4;
    char tq_val[5]={0}, mac[18]={0}, rssi[5]={0}, tx_rate[8]={0}, rx_rate[8]={0};
    struct json_object *jarr_mesh_learn_table, *jobj_mesh_learn_table;
    struct json_object *jobj_mesh_robust, *jarr_mesh_node_tq, *jobj_mesh_node_tq, *jarr_mesh_link, *jobj_mesh_link, *jobj_gw_mac_addr;
    ResponseStatus *res = rep->res;

    jobj_mesh_learn_table = json_object_new_object();
    jobj_mesh_robust = json_object_new_object();
    jobj_mesh_node_tq = json_object_new_object();
    jobj_mesh_link = json_object_new_object();
    jobj_gw_mac_addr = json_object_new_object();

    sys_interact(mesh_disable, sizeof(mesh_disable), "uci get mesh.wifi.disabled");

    /* mesh_role */
    sys_interact(mesh_role, sizeof(mesh_role), "batctl gw |awk '{printf $1}'");

    if ( strcmp(mesh_role, "client") == 0)
        strcpy(mesh_role, "AP");
    else
        strcpy(mesh_role, "Gateway");

    /* mesh_channel */
    api_get_mesh_disabled_option(WIRELESS_WIFI_MESH_DISABLED_OPTION, &wifix);
    api_get_wifi_mesh_ifname_option(wifix, ifname, sizeof(ifname));
    uci_get_wifix_mesh_channel_option(wifix, &mesh_channel);

    json_object_object_add(jobj, "mesh_role", json_object_new_string(mesh_role));
    json_object_object_add(jobj, "mesh_channel", json_object_new_int(mesh_channel));

    if (atoi(mesh_disable) == 0)
    {
        sys_interact(buf, sizeof(buf), "batctl o -H |wc -l");
        mesh_num = atoi(buf);
        memset(buf, 0, sizeof(buf));
        sys_interact(buf, sizeof(buf), "batctl o |grep No");
    }
    else
        strcpy(buf,"");

    if (strcmp(buf, "") == 0 && atoi(mesh_disable) == 0)
    {
        /* ---------------mesh_learn_table----------------*/
        /* mac_addr */
        sys_interact(mac_addr, sizeof(mac_addr), "wlanconfig %s nawds learning |tail -n +5 |head -n %d| awk '{print $2}'| tr -d '\n'", ifname, mesh_num);

        /* learn_rssi */
        sys_interact(learn_rssi, sizeof(learn_rssi), "wlanconfig %s list |tail -n +2|awk '{print $6}' | tr -d '\n'", ifname);

        /* link_flags */
        sys_interact(link_flags, sizeof(link_flags), "wlanconfig %s nawds learning |tail -n +5 | head -n %d| awk -F '[' '{print $2}' |awk -F ']' '{print $1}' | tr -d '\n'", ifname, mesh_num);

        strcpy(mac, mac_addr);
        strcpy(rssi, learn_rssi);
        pch = strtok_r(mac_addr, "\n", &saveptr1);
        pch2 = strtok_r(learn_rssi, "\n", &saveptr2);
        pch3 = strtok_r(link_flags, "\n", &saveptr3);

        while(pch !=NULL)
        {
            jarr_mesh_learn_table = json_object_new_array();
            json_object_object_add(jobj_mesh_learn_table, "mac_addr", json_object_new_string(pch));
            json_object_object_add(jobj_mesh_learn_table, "learn_rssi", json_object_new_int(atoi(pch2)));
            json_object_object_add(jobj_mesh_learn_table, "link_flags", json_object_new_string(pch3));
            json_object_array_add(jarr_mesh_learn_table, jobj_mesh_learn_table);

            pch = strtok_r(saveptr1, "\n", &saveptr1);
            pch2 = strtok_r(saveptr2, "\n", &saveptr2);
            pch3 = strtok_r(saveptr3, "\n", &saveptr3);
        }

        json_object_object_add(jobj, "mesh_learn_table", jarr_mesh_learn_table);

        /* ---------------mesh_robust----------------*/
        /* enable */
        memset(buf, 0, sizeof(buf));
        sys_interact(buf, sizeof(buf), "cat /proc/mesh_robust |awk {'printf $1'}");
        enable=(atoi(buf) == 1?true:false);

        /* threshold */
        memset(buf, 0, sizeof(buf));
        if (wifix == 0)
            sys_interact(buf, sizeof(buf), "cat /proc/mesh_robust |awk {'printf $2'}");
        else
            sys_interact(buf, sizeof(buf), "cat /proc/mesh_robust |awk {'printf $3'}");
        threshold = atoi(buf);

        json_object_object_add(jobj_mesh_robust, "enable", json_object_new_boolean(enable));
        json_object_object_add(jobj_mesh_robust, "threshold", json_object_new_int(threshold));
        json_object_object_add(jobj, "mesh_robust", jobj_mesh_robust);

        /* ---------------mesh_node_tq----------------*/
        /* mac_addr */
        memset(mac_addr, 0, sizeof(mac_addr));
        sys_interact(mac_addr, sizeof(mac_addr), "batctl o -H | awk {'print $2'}");
        /* tq_val */
        sys_interact(tq_val, sizeof(tq_val), " batctl o -H | awk -F '(' '{print $2}' | awk -F ')' '{print $1}'");
        pch = strtok_r(mac_addr, "\n", &saveptr1);
        pch2 = strtok_r(tq_val, "\n", &saveptr2);

        while(pch !=NULL)
        {
            jarr_mesh_node_tq = json_object_new_array();
            json_object_object_add(jobj_mesh_node_tq, "mac_addr", json_object_new_string(pch));
            json_object_object_add(jobj_mesh_node_tq, "tq_val", json_object_new_int(atoi(pch2)));
            json_object_array_add(jarr_mesh_node_tq, jobj_mesh_node_tq);

            pch = strtok_r(saveptr1, "\n", &saveptr1);
            pch2 = strtok_r(saveptr2, "\n", &saveptr2);
        }
        json_object_object_add(jobj, "mesh_node_tq", jarr_mesh_node_tq);

        /* ---------------mesh_link----------------*/
        /* mac_addr */
        /* rssi */
        /* tx_datarate */
        sys_interact(tx_rate, sizeof(tx_rate), "wlanconfig %s list |tail -n +2|awk '{print $4}' | tr -d '\n'", ifname);
        /* rx_datarate */
        sys_interact(rx_rate, sizeof(rx_rate), "wlanconfig %s list |tail -n +2|awk '{print $5}' | tr -d '\n'", ifname);
        pch = strtok_r(mac, "\n", &saveptr1);
        pch2 = strtok_r(rssi, "\n", &saveptr2);
        pch3 = strtok_r(tx_rate, "\n", &saveptr3);
        pch4 = strtok_r(rx_rate, "\n", &saveptr4);

        while(pch !=NULL)
        {
            jarr_mesh_link = json_object_new_array();
            json_object_object_add(jobj_mesh_link, "mac_addr", json_object_new_string(pch));
            json_object_object_add(jobj_mesh_link, "rssi", json_object_new_int(atoi(pch2)));
            json_object_object_add(jobj_mesh_link, "tx_datarate", json_object_new_int(atoi(pch3)));
            json_object_object_add(jobj_mesh_link, "rx_datarate", json_object_new_int(atoi(pch4)));
            json_object_array_add(jarr_mesh_link, jobj_mesh_link);

            pch = strtok_r(saveptr1, "\n", &saveptr1);
            pch2 = strtok_r(saveptr2, "\n", &saveptr2);
            pch3 = strtok_r(saveptr3, "\n", &saveptr3);
            pch4 = strtok_r(saveptr4, "\n", &saveptr4);
        }

        json_object_object_add(jobj, "mesh_link", jarr_mesh_link);

        /* ---------------mesh_outgoing_gw----------------*/
        if (strcmp(mesh_role, "AP") == 0) 
        {
            /* gw_mac_addr */
            memset(buf, 0, sizeof(buf));
            sys_interact(buf, sizeof(buf), "batctl gwl | grep '*' |awk {'printf $2'} | tr -d '\n'");
            json_object_object_add(jobj_gw_mac_addr, "gw_mac", json_object_new_string(buf));
            /* next_hop_mac_addr */
            memset(buf, 0, sizeof(buf));
            sys_interact(buf, sizeof(buf), "batctl gwl | grep '*' |awk {'printf $4'} | tr -d '\n'");
            json_object_object_add(jobj_gw_mac_addr, "next_hop_mac", json_object_new_string(buf));
        }
        else
        {
            json_object_object_add(jobj_gw_mac_addr, "gw_mac", json_object_new_string(""));
            json_object_object_add(jobj_gw_mac_addr, "next_hop_mac", json_object_new_string(""));
        }
        json_object_object_add(jobj, "mesh_outgoing_gw", jobj_gw_mac_addr);
    }
    else
    {
        json_object_object_add(jobj, "mesh_role", json_object_new_string("unknown"));
        json_object_object_add(jobj, "mesh_channel", json_object_new_int(0));

        jarr_mesh_learn_table = json_object_new_array();
        json_object_object_add(jobj_mesh_learn_table, "mac_addr", json_object_new_string("00:00:00:00:00:00"));
        json_object_object_add(jobj_mesh_learn_table, "learn_rssi", json_object_new_int(0));
        json_object_object_add(jobj_mesh_learn_table, "link_flags", json_object_new_string(".."));
        json_object_array_add(jarr_mesh_learn_table, jobj_mesh_learn_table);
        json_object_object_add(jobj, "mesh_learn_table", jarr_mesh_learn_table);

        json_object_object_add(jobj_mesh_robust, "enable", json_object_new_boolean(false));
        json_object_object_add(jobj_mesh_robust, "threshold", json_object_new_int(0));
        json_object_object_add(jobj, "mesh_robust", jobj_mesh_robust);

        jarr_mesh_node_tq = json_object_new_array();
        json_object_object_add(jobj_mesh_node_tq, "mac_addr", json_object_new_string("00:00:00:00:00:00"));
        json_object_object_add(jobj_mesh_node_tq, "tq_val", json_object_new_int(0));
        json_object_array_add(jarr_mesh_node_tq, jobj_mesh_node_tq);
        json_object_object_add(jobj, "mesh_node_tq", jarr_mesh_node_tq);

        jobj_mesh_link = json_object_new_array();
        json_object_object_add(jobj_mesh_link, "mac_addr", json_object_new_string("00:00:00:00:00:00"));
        json_object_object_add(jobj_mesh_link, "rssi", json_object_new_int(0));
        json_object_object_add(jobj_mesh_link, "tx_datarate", json_object_new_int(0));
        json_object_object_add(jobj_mesh_link, "rx_datarate", json_object_new_int(0));
        json_object_array_add(jarr_mesh_link, jobj_mesh_link);
        json_object_object_add(jobj, "mesh_link", jarr_mesh_link);

        json_object_object_add(jobj_gw_mac_addr, "gw_mac", json_object_new_string("00:00:00:00:00:00"));
        json_object_object_add(jobj_gw_mac_addr, "next_hop_mac", json_object_new_string("00:00:00:00:00:00"));
        json_object_object_add(jobj, "mesh_outgoing_gw", jobj_gw_mac_addr);
    }

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_get_mesh_group_info(ResponseEntry *rep, struct json_object *jobj){

    struct json_object *jobj2, *jobj3;
    struct json_object *jarr, *jarr_obj;
    struct json_object *jarr_mesh_learn_table, *jarr_mesh_link;
    struct json_object *jobj_mesh_learn_table, *jobj_mesh_robust, *jobj_gw_mac_addr, *jobj_mesh_link;
    struct json_object *medi_array_obj, *medi_array_obj2, *medi_array_obj_name, *medi_array_obj3, *medi_array_obj4;
    struct json_object *MeshResult, *MeshRole, *MacAddress, *MeshController, *MAC, *mesh_learn_table, *mesh_link;
    struct json_object *LANMacAddress, *WANMacAddress, *TQ, *NextHopRssi, *NextHopMac, *Neighbors, *RSSI;
    struct json_object *DevMacAddr, *MeshChannel, *MacAddr, *LearnRssi, *LinkFlags, *RobustEnable, *RobustThreshold, *TqVal, *TxDatarate, *RxDatarate, *GwMacAddr;
    struct device_info all_device[128]={0};
    int i, j, array_length, array_length_ResultOK=0, flags=0, neighbors_length=0, MaxRSSI=0, mesh_learn_table_length=0, mesh_link_length=0;
    char buf[20480]={0}, master_mesh_mac[64], mesh_id[16]={0}, mesh_pw[64]={0}, ptr[128];
    ResponseStatus *res = rep->res;

    /* mesh_id */
    api_get_wifi_mesh_id_option(WIRELESS_WIFI_MESH_ID_OPTION , mesh_id, sizeof(mesh_id));
    /* mesh_pw */
    api_get_wifi_mesh_wpa_key_option(WIRELESS_WIFI_MESH_AESKEY_OPTION , mesh_pw, sizeof(mesh_pw));

    sprintf(ptr, "%s %s %s", "/sbin/mesh.sh get_mesh_global_node_info", mesh_id, mesh_pw);
    system(ptr);

    if(sys_check_file_existed("/tmp/mesh_global_node_info"))
    {
        sys_interact(buf, sizeof(buf), "cat /tmp/mesh_global_node_info");
        jobj2 = jsonTokenerParseFromStack(rep, buf);

        if((jobj2 != NULL))
        {
            array_length = json_object_array_length(jobj2);
        }
        else
        {
            RET_GEN_ERRORMSG(res, API_SERVICE_ERROR, "CAN'T GET MESH GROUP INFO");
        }

        for (i = 0; i < array_length; i++)
        {
            medi_array_obj = json_object_array_get_idx(jobj2, i);
            MeshResult = json_object_object_get(medi_array_obj, "GetMeshNodeInfoResult");
            if (strcmp(json_object_get_string(MeshResult), "OK") == 0)
            {
                medi_array_obj_name = json_object_object_get(medi_array_obj, "MeshGroupInfo");
				MeshRole = json_object_object_get(medi_array_obj_name, "MeshRole");
                LANMacAddress = json_object_object_get(medi_array_obj_name, "LANMacAddress");
				MacAddress = json_object_object_get(medi_array_obj_name, "MacAddress");
                NextHopMac = json_object_object_get(medi_array_obj_name, "NextHopMac");
                MeshController = json_object_object_get(medi_array_obj_name, "MeshController");
                DevMacAddr = json_object_object_get(medi_array_obj_name, "Dev_Mac_Addr");
                MeshChannel = json_object_object_get(medi_array_obj_name, "Mesh_Channel");
                RobustEnable = json_object_object_get(medi_array_obj_name, "Robust_Enable");
                RobustThreshold = json_object_object_get(medi_array_obj_name, "Robust_Threshold");
                GwMacAddr = json_object_object_get(medi_array_obj_name, "Gw_Mac_Addr");
                strcpy(all_device[array_length_ResultOK].LANMacAddress, json_object_get_string(LANMacAddress));
                strcpy(all_device[array_length_ResultOK].mac, json_object_get_string(MacAddress));
                strcpy(all_device[array_length_ResultOK].meshRole, json_object_get_string(MeshRole));
                strcpy(all_device[array_length_ResultOK].GwMacAddr, json_object_get_string(GwMacAddr));
                all_device[array_length_ResultOK].MeshChannel = json_object_get_int(MeshChannel);
                all_device[array_length_ResultOK].Enable = json_object_get_boolean(RobustEnable);
                all_device[array_length_ResultOK].Threshold = json_object_get_int(RobustThreshold);
                strcpy(all_device[array_length_ResultOK].meshController, (json_object_get_string(MeshController) != NULL) ? json_object_get_string(MeshController) : "slave");

                mesh_learn_table = json_object_object_get(medi_array_obj_name, "mesh_learn_table");
                mesh_learn_table_length = json_object_array_length(mesh_learn_table);
                for (j=0;j<mesh_learn_table_length;j++)
				{
				  medi_array_obj3 = json_object_array_get_idx(mesh_learn_table, j);
                  MacAddr = json_object_object_get(medi_array_obj3, "Mac_Addr");
                  LearnRssi = json_object_object_get(medi_array_obj3, "Learn_Rssi");
                  LinkFlags = json_object_object_get(medi_array_obj3, "Link_Flags");
                  strcpy(all_device[array_length_ResultOK].MacAddr[j], json_object_get_string(MacAddr));
                  strcpy(all_device[array_length_ResultOK].LearnRssi[j], json_object_get_string(LearnRssi));
                  strcpy(all_device[array_length_ResultOK].LinkFlags[j], json_object_get_string(LinkFlags));
				}

                mesh_link = json_object_object_get(medi_array_obj_name, "mesh_link");
                mesh_link_length = json_object_array_length(mesh_link);
                for (j=0;j<mesh_link_length;j++)
				{
				  medi_array_obj4 = json_object_array_get_idx(mesh_link, j);
                  TqVal = json_object_object_get(medi_array_obj4, "Tq_Val");
                  TxDatarate = json_object_object_get(medi_array_obj4, "Tx_Datarate");
                  RxDatarate = json_object_object_get(medi_array_obj4, "Rx_Datarate");
                  strcpy(all_device[array_length_ResultOK].TqVal, json_object_get_string(TqVal));
                  strcpy(all_device[array_length_ResultOK].TxRate[j], json_object_get_string(TxDatarate));
                  strcpy(all_device[array_length_ResultOK].RxRate[j], json_object_get_string(RxDatarate));
				}

                if(0 == strcmp("server", all_device[array_length_ResultOK].meshRole) &&
				   0 == strcmp("slave", all_device[array_length_ResultOK].meshController))
				{
					sys_interact(all_device[array_length_ResultOK].NextHopMac,
							sizeof(all_device[array_length_ResultOK].NextHopMac),
							"/usr/shc/getMeshNextHop %s %s",
							all_device[array_length_ResultOK].LANMacAddress,
							all_device[array_length_ResultOK].mac);
					all_device[array_length_ResultOK].NextHopRssi = 100;
				}
				else
				{
					if(0 == strcmp("server", all_device[array_length_ResultOK].meshRole) &&
					   0 == strcmp("master", all_device[array_length_ResultOK].meshController))
					{
						memset(master_mesh_mac, 0x00, sizeof(master_mesh_mac));
						sprintf(master_mesh_mac, "%s", all_device[array_length_ResultOK].mac);
					}

					strcpy(all_device[array_length_ResultOK].NextHopMac, (json_object_get_string(NextHopMac) != NULL) ? json_object_get_string(NextHopMac) : "");
					all_device[array_length_ResultOK].NextHopRssi = (NextHopRssi != NULL) ? json_object_get_int(NextHopRssi) : 0;
				}
                array_length_ResultOK++;
            }
        }

        for (i=0;i<array_length_ResultOK;i++)
        {
           jarr_obj = json_object_new_object();
           json_object_object_add(jarr_obj, "dev_mac_addr", json_object_new_string(all_device[i].mac));
           json_object_object_add(jarr_obj, "mesh_role", json_object_new_string(all_device[i].meshRole));
           json_object_object_add(jarr_obj, "mesh_channel", json_object_new_int(all_device[i].MeshChannel));

           jarr_mesh_learn_table = json_object_new_array();
           j = 0;
           while(0 != strlen(all_device[i].MacAddr[j]))
           {
             jobj_mesh_learn_table = json_object_new_object();
             json_object_object_add(jobj_mesh_learn_table, "mac_addr", json_object_new_string(all_device[i].MacAddr[j]));
             json_object_object_add(jobj_mesh_learn_table, "learn_rssi", json_object_new_string(all_device[i].LearnRssi[j]));
             json_object_object_add(jobj_mesh_learn_table, "link_flags", json_object_new_string(all_device[i].LinkFlags[j]));
             json_object_array_add(jarr_mesh_learn_table, jobj_mesh_learn_table);
             j++;
           }
           json_object_object_add(jarr_obj, "mesh_learn_table", jarr_mesh_learn_table);

           jobj_mesh_robust = json_object_new_object();
           json_object_object_add(jobj_mesh_robust, "enable", json_object_new_boolean(all_device[i].Enable));
           json_object_object_add(jobj_mesh_robust, "threshold", json_object_new_int(all_device[i].Threshold));
           json_object_object_add(jarr_obj, "mesh_robust", jobj_mesh_robust);

           jarr_mesh_link = json_object_new_array();
           j = 0;
           while(0 != strlen(all_device[i].MacAddr[j]))
           {
              jobj_mesh_link = json_object_new_object();
              json_object_object_add(jobj_mesh_link, "mac_addr", json_object_new_string(all_device[i].MacAddr[j]));
              json_object_object_add(jobj_mesh_link, "rssi", json_object_new_int(all_device[i].rssi));
              json_object_object_add(jobj_mesh_link, "tq_val", json_object_new_string(all_device[i].TqVal));
              json_object_object_add(jobj_mesh_link, "tx_datarate", json_object_new_string(all_device[i].TxRate[j]));
              json_object_object_add(jobj_mesh_link, "rx_datarate", json_object_new_string(all_device[i].RxRate[j]));
              json_object_array_add(jarr_mesh_link, jobj_mesh_link);
              j++;
           }
           json_object_object_add(jarr_obj, "mesh_link", jarr_mesh_link);

           jobj_gw_mac_addr = json_object_new_object();
           json_object_object_add(jobj_gw_mac_addr, "gw_mac_addr", json_object_new_string(all_device[i].GwMacAddr));
           json_object_object_add(jobj_gw_mac_addr, "next_hop_mac_addr", json_object_new_string(all_device[i].NextHopMac));
           json_object_object_add(jarr_obj, "mesh_outgoing_gw", jobj_gw_mac_addr);

           json_object_array_add(jobj, jarr_obj);
        }
    }
    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_get_ethernet(ResponseEntry *rep, struct json_object *jobj){

    int val = 0, lacp_mode = 0, vlanEn=0, vlanId=0, linklocal_en=0, prefix=0;
    char *mode, ip[16]={0}, mask[16]={0}, gateway[16]={0}, pDns[16]={0}, sDns[16]={0}, pDns6[64]={0}, sDns6[64]={0}, ip6_addr[64]={0}, ip6_gateway[64]={0};
    char cur_lan_mask[32] = {0}, cur_dnslist[64] = {0}, cur_dns1[32] = {0}, cur_dns2[32] = {0}, cur_ipv6_link[64] = {0}, cur_ipv6_addr[64] = {0}, cur_ipv6_gwaddr[64] = {0}, cur_ipv6_dnslist[128] = {0}, cur_ipv6_dns1[64] = {0}, cur_ipv6_dns2[64] = {0};
    char cur_lan_ip[32] = {0}, cur_lan_gateway[32] = {0};
    char networkHostName[33] = {0};
    struct json_object *jobj_ipv4;
    struct json_object *jobj_static;
    struct json_object *jobj_ipv6;
    jobj_ipv4 = json_object_new_object();
    jobj_static = json_object_new_object();
    jobj_ipv6 = json_object_new_object();
    ResponseStatus *res = rep->res;

    /* mode */
    api_get_lan_proto_option(NETWORK_LAN_PROTO_OPTION, &val);
    mode = (val == 0) ? "Static" : "DHCP";

#if SUPPORT_ETHERNET_BONDING
    /* lacp_mode */
    api_get_lan_lacp_option(&lacp_mode);
#else // get from no use config
    api_get_integer_option("network.lan.lacp_mode",&lacp_mode);
#endif

    /* current lan ip */
    sys_interact(cur_lan_ip, sizeof(cur_lan_ip), "ifconfig br-lan |grep Bcast |awk {'printf $2'} |awk -F : {'printf $2'}");

    /* current lan mask */
    sys_interact(cur_lan_mask, sizeof(cur_lan_mask), "ifconfig br-lan | grep 'inet addr' | awk -F ' ' '{print $4}' | awk -F ':' '{print $2}'");
    if ( cur_lan_mask[strlen(cur_lan_mask)-1] == '\n' )
        cur_lan_mask[strlen(cur_lan_mask)-1] = 0;

    /* current lan gateway */
    sys_interact(cur_lan_gateway, sizeof(cur_lan_gateway), "route -n| grep 'UG[ \t]'|awk '{ printf $2 }'");

    sys_interact(cur_dnslist, sizeof(cur_dnslist), "cat /tmp/resolv.conf.auto | grep nameserver| grep -v ':'| cut -d ' ' -f 2");
    sscanf(cur_dnslist, "%s %s", cur_dns1, cur_dns2);
    if(strcmp(cur_dns1, "") == 0)
        strcpy(cur_dns1, "N/A");
    if(strcmp(cur_dns2, "") == 0)
        strcpy(cur_dns2, "N/A");
    //debug_print("============cur_dns1:[%s]==========cur_dns2:[%s]\n", cur_dns1, cur_dns2);

#if SUPPORT_IPV6_SETTING
    sys_interact(cur_ipv6_addr, sizeof(cur_ipv6_addr), "ip -6 addr show br-lan | grep 'scope global' | sed -n '1p' | sed 's/^.*inet6 //g' | sed 's/\\/.*$//g'");
    if ( cur_ipv6_addr[strlen(cur_ipv6_addr)-1] == '\n' )
        cur_ipv6_addr[strlen(cur_ipv6_addr)-1] = 0;
    if(strcmp(cur_ipv6_addr, "") == 0)
        strcpy(cur_ipv6_addr, "N/A");

    sys_interact(cur_ipv6_link, sizeof(cur_ipv6_link), "ifconfig br-lan | grep inet6 | grep Link | awk '{print $3}'| sed 's/\\/.*$//g'");
    if ( cur_ipv6_link[strlen(cur_ipv6_link)-1] == '\n' )
        cur_ipv6_link[strlen(cur_ipv6_link)-1] = 0;

    sys_interact(cur_ipv6_gwaddr, sizeof(cur_ipv6_gwaddr), "ip -6 route show default | grep 'br-lan' | sed -n '1p' | sed 's/^.*via //g' | sed 's/ .*$//g'");
    if ( cur_ipv6_gwaddr[strlen(cur_ipv6_gwaddr)-1] == '\n' )
        cur_ipv6_gwaddr[strlen(cur_ipv6_gwaddr)-1] = 0;
    if(strcmp(cur_ipv6_gwaddr, "") == 0)
        strcpy(cur_ipv6_gwaddr, "N/A");

    sys_interact(cur_ipv6_dnslist, sizeof(cur_ipv6_dnslist), "cat /tmp/resolv.conf.auto | grep -E '^nameserver.*:' | grep -wv '::1' | cut -d ' ' -f 2");
    sscanf(cur_ipv6_dnslist, "%s %s", cur_ipv6_dns1, cur_ipv6_dns2);
    if(strcmp(cur_ipv6_dns1, "") == 0)
        strcpy(cur_ipv6_dns1, "N/A");
    if(strcmp(cur_ipv6_dns2, "") == 0)
        strcpy(cur_ipv6_dns2, "N/A");
    //debug_print("============cur_ipv6_dns1:[%s]==========cur_ipv6_dns2:[%s]\n", cur_ipv6_dns1, cur_ipv6_dns2);
#endif

    /* ip */
    api_get_lan_ipaddr_option(NETWORK_LAN_IPADDR_OPTION, ip, sizeof(ip));

    /* mask */
    api_get_lan_netmask_option(NETWORK_LAN_NETMASK_OPTION, mask, sizeof(mask));

    /* gateway */
    api_get_lan_gateway_option(NETWORK_LAN_GATEWAY_OPTION, gateway, sizeof(gateway));

    /* primary_dns */
    api_get_lan_dns_option(NETWORK_LAN_DNS_OPTION, 1, pDns, sizeof(pDns));

    /* secondary_dns */
    api_get_lan_dns_option(NETWORK_LAN_DNS_OPTION, 2, sDns, sizeof(sDns));

    /* vlan enable */
    api_get_integer_option(NETWORK_SYSTEM_WLANVLANENABLE_OPTION, &vlanEn);

    /* vlan id */
    api_get_integer_option(NETWORK_SYSTEM_MANAGEMENTVLANID_OPTION, &vlanId);

#if SUPPORT_IPV6_SETTING
    /* link local */
    api_get_lan_ipv6_link_local_option(NETWORK_LAN_IPV6_LINK_LOCAL_OPTION, &linklocal_en);

    /* ipv6 addr */
    api_get_lan_ipv6_addr_option(NETWORK_LAN_IPV6_IPADDR_OPTION, ip6_addr, sizeof(ip6_addr));

    /* ipv6 prefix */
    api_get_lan_ipv6_subnet_prefix_length_option(NETWORK_LAN_IPV6_IPADDR_OPTION, &prefix);

    /* ipv6 gateway */
    api_get_lan_ipv6_gateway_option(NETWORK_LAN_IPV6_GATEWAY_OPTION, ip6_gateway, sizeof(ip6_gateway));

    /* primary_dns v6 */
    api_get_lan_dns_option(NETWORK_LAN_DNS_OPTION, 3, pDns6, sizeof(pDns6));

    /* secondary_dns v6 */
    api_get_lan_dns_option(NETWORK_LAN_DNS_OPTION, 4, sDns6, sizeof(sDns6));
#endif

    api_get_system_hostname_option(NETWORK_LAN_HOSTNAME_OPTION, networkHostName, sizeof(networkHostName));

    json_object_object_add(jobj_ipv4, "ip", json_object_new_string(ip));
    json_object_object_add(jobj_ipv4, "mask", json_object_new_string(mask));
    json_object_object_add(jobj_ipv4, "gateway", json_object_new_string(gateway));
    json_object_object_add(jobj_ipv4, "primary_dns", json_object_new_string(pDns));
    json_object_object_add(jobj_ipv4, "secondary_dns", json_object_new_string(sDns));
    json_object_object_add(jobj_ipv4, "cur_ipv4_ip", json_object_new_string(cur_lan_ip));
    json_object_object_add(jobj_ipv4, "cur_ipv4_mask", json_object_new_string(cur_lan_mask));
    json_object_object_add(jobj_ipv4, "cur_ipv4_gateway", json_object_new_string(cur_lan_gateway));
    json_object_object_add(jobj_ipv4, "cur_ipv4_dns1", json_object_new_string(cur_dns1));
    json_object_object_add(jobj_ipv4, "cur_ipv4_dns2", json_object_new_string(cur_dns2));

#if SUPPORT_IPV6_SETTING
    json_object_object_add(jobj_ipv6, "linklocal", json_object_new_boolean(linklocal_en));
    json_object_object_add(jobj_ipv6, "ip", json_object_new_string(ip6_addr));
    json_object_object_add(jobj_ipv6, "prefix", json_object_new_int(prefix));
    json_object_object_add(jobj_ipv6, "gateway", json_object_new_string(ip6_gateway));
    json_object_object_add(jobj_ipv6, "primary_dns", json_object_new_string(pDns6));
    json_object_object_add(jobj_ipv6, "secondary_dns", json_object_new_string(sDns6));
    json_object_object_add(jobj_ipv6, "cur_ipv6_addr", json_object_new_string(cur_ipv6_addr));
    json_object_object_add(jobj_ipv6, "cur_ipv6_link", json_object_new_string(cur_ipv6_link));
    json_object_object_add(jobj_ipv6, "cur_ipv6_gwaddr", json_object_new_string(cur_ipv6_gwaddr));
    json_object_object_add(jobj_ipv6, "cur_ipv6_dns1", json_object_new_string(cur_ipv6_dns1));
    json_object_object_add(jobj_ipv6, "cur_ipv6_dns2", json_object_new_string(cur_ipv6_dns2));
#endif
    json_object_object_add(jobj, "lacp_mode", json_object_new_boolean(lacp_mode));
    json_object_object_add(jobj, "mgm_vlan_enable", json_object_new_boolean(vlanEn));
    json_object_object_add(jobj, "mgm_vlan_id", json_object_new_int(vlanId));
    json_object_object_add(jobj, "mode", json_object_new_string(mode));
    json_object_object_add(jobj, "hostname", json_object_new_string(networkHostName));

    json_object_object_add(jobj, "ipv4", jobj_ipv4);
#if SUPPORT_IPV6_SETTING
    json_object_object_add(jobj, "ipv6", jobj_ipv6);
#endif

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_get_ethernet_traffic_info(ResponseEntry *rep, struct json_object *jobj)
{
    char tx_bytes[512] = {0}, rx_bytes[512] = {0}, tmp_bytes[512] = {0};
    char ifname[16] = {0};
    char *ifname_s = NULL, *p = NULL;
    unsigned long long tx_byte = 0, rx_byte = 0, tmp_byte = 0;

    ResponseStatus *res = rep->res;

    //strcpy(ifname, "eth0");
    sys_interact(ifname, sizeof(ifname), "uci -q get /rom/etc/config/network.lan.ifname");
    if ( strlen(ifname) > 0 && ifname[strlen(ifname)-1] == '\n' )
        ifname[strlen(ifname)-1] = '\0';
    debug_print("%s[%d]===>ifname[%s]  len[%d]\n", __FUNCTION__, __LINE__,ifname,strlen(ifname));

    if (strlen(ifname)>5)
    {
        ifname_s = strtok_r(ifname, " ", &p);
        while(ifname_s != NULL){
            sys_interact(tmp_bytes, sizeof(tmp_bytes), "ifconfig %s |grep \"TX bytes\"|awk -F ':' '{print $3}'|awk -F ' ' '{print $1}'", ifname_s);
            if ( strlen(tmp_bytes) > 0 && tmp_bytes[strlen(tmp_bytes)-1] == '\n' )
                tmp_bytes[strlen(tmp_bytes)-1] = 0;
            sscanf(tmp_bytes, "%llu", &tmp_byte);
            tx_byte = tx_byte + tmp_byte;

            sys_interact(tmp_bytes, sizeof(tmp_bytes), "ifconfig %s |grep \"RX bytes\"|awk -F ':' '{print $2}'|awk -F ' ' '{print $1}'", ifname_s);
            if ( strlen(tmp_bytes) > 0 && tmp_bytes[strlen(tmp_bytes)-1] == '\n' )
                tmp_bytes[strlen(tmp_bytes)-1] = 0;
            sscanf(tmp_bytes, "%llu", &tmp_byte);
            rx_byte = rx_byte + tmp_byte;

            debug_print("%s[%d]===>ifname_s[%s],tx_byte[%llu],rx_byte[%llu]\n", __FUNCTION__, __LINE__,ifname_s,tx_byte,rx_byte);
            ifname_s = strtok_r(NULL, " ", &p);
        }
        sprintf(tx_bytes, "%llu", tx_byte);
        sprintf(rx_bytes, "%llu", rx_byte);
    }
    else
    {
    sys_interact(tx_bytes, sizeof(tx_bytes), "ifconfig %s |grep \"TX bytes\"|awk -F ':' '{print $3}'|awk -F ' ' '{print $1}'", ifname);
    if ( strlen(tx_bytes) > 0 && tx_bytes[strlen(tx_bytes)-1] == '\n' )
        tx_bytes[strlen(tx_bytes)-1] = 0;

    sys_interact(rx_bytes, sizeof(rx_bytes), "ifconfig %s |grep \"RX bytes\"|awk -F ':' '{print $2}'|awk -F ' ' '{print $1}'", ifname);
    if ( strlen(rx_bytes) > 0 && rx_bytes[strlen(rx_bytes)-1] == '\n' )
        rx_bytes[strlen(rx_bytes)-1] = 0;
    }

    json_object_object_add(jobj, "tx_bytes", json_object_new_string(tx_bytes));
    json_object_object_add(jobj, "rx_bytes", json_object_new_string(rx_bytes));

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}
int json_get_ethernet_client_info(ResponseEntry *rep, struct json_object *jobj)
{
    char cmd[256]={0}, mac_addr[32]={0};
    char mac_str[32] = {0};
    struct json_object* jarr;
    struct json_object* jobj_tmp;

    ResponseStatus *res = rep->res;

    FILE *pp;
    snprintf(cmd, sizeof(cmd), "ssdk_sh fdb entry show | grep addr | grep -v \"\\[dest_port\\]:0\" | awk -F: {'print $2'} | awk {'print $1'} | sed s/-/:/g");
    pp = popen(cmd, "r");
    if (pp == NULL)
    {
        debug_print("popen() error!\n");
    }
    else
    {
        jarr = newObjectArrayFromStack(rep);
        while (fgets(mac_str, sizeof(mac_str), pp) != NULL) {
            if (mac_str[strlen(mac_str)-1] == '\n')
            {
                mac_str[strlen(mac_str)-1] = '\0';
            }
            jobj_tmp = newObjectFromStack(rep);
            json_object_object_add(jobj_tmp, "mac_addr", json_object_new_string(mac_str));
            json_object_array_add(jarr, jobj_tmp);
        }
        json_object_object_add(jobj, "client", jarr);
    }
    pclose(pp);

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}
#if HAS_SYSEYE
char command_checkall[]="{\"Actions\": [ \
		{ \
			\"name\": \"act_check_phylink\", \
			\"command\": \"act_check_phylink\" \
		}, \
		{ \
			\"name\": \"act_check_arpdup\", \
			\"command\": \"act_check_arpdup\" \
		}, \
		{ \
			\"name\": \"act_check_icmp\", \
			\"command\": \"act_check_icmp\" \
		}, \
		{ \
			\"name\": \"act_check_dns\", \
			\"command\": \"act_check_dns\" \
		}, \
		{ \
			\"name\": \"act_check_http\", \
			\"command\": \"act_check_http\" \
		}, \
		{ \
			\"name\": \"act_check_https\", \
			\"command\": \"act_check_https\" \
		} \
	]\
}";
#endif // HAS_SYSEYE
int json_post_linktest(ResponseEntry *rep, struct json_object *jobj){
    ResponseStatus *res = rep->res;
#if HAS_SYSEYE
    struct seipc_t *handle=NULL;
    JsonNode *setjs, *resjs;
    int resultPath = 0;

    // send check command to syseye
    setjs = js_parse_str(command_checkall);

    if (!(handle = seipc_create(__progname, SYSEYE_PATH))){
        js_free(setjs);
        RET_GEN_ERRORMSG(res, API_INTERNAL_ERROR, "ipc connect fail, check syseye.");
    }

    if ((resjs = seipc_actions(handle, setjs))==NULL){
        js_free(setjs);
        seipc_close(handle);
        RET_GEN_ERRORMSG(res, API_INTERNAL_ERROR, "act_linktest action fault, check syseye");
    }

    if (js_get_path(resjs, "resultPath") == NULL ||
        (resultPath = js_get_path_int(resjs,"resultPath")) < 0){
        js_free(setjs);
        js_free(resjs);
        seipc_close(handle);
        RET_GEN_ERRORMSG(res, API_INTERNAL_ERROR, "ipc return malformed, get resultPath error, check syseye");
    }
    js_free(setjs);
    js_free(resjs);
    seipc_close(handle);

    json_object_object_add(jobj, "resultPath", json_object_new_int(resultPath));
    RET_GEN_ERRORMSG(res, API_SUCCESS, "Use json_get_linktest to get result.");
#else // HAS_SYSEYE
#if HAS_LINKMON
    char iface[16];
    uint32_t gw;
    struct in_addr addr;
    char cmd[128];
    if (get_if_waninfo(iface, &gw) == -1){
        debug_print("gateway got fail");
        strcpy(iface, "br-lan");
        gw=0;
    }

    addr.s_addr=gw;
    char pDNS[16]={0};
//    api_get_lan_dns_option(NETWORK_LAN_DNS_OPTION, 1, pDNS, sizeof(pDNS));
    if (get_dns_addr(pDNS) == -1) // no dns server, let query fail
	    strcpy(pDNS, "0.0.0.0");

    if (gw != 0)
        sprintf(cmd, "linkmon -l 60 -i %s -a %s -n %s -q %s -d", iface, inet_ntoa(addr), pDNS, "aws.amazon.com");
    else { // no gateway, let linkmon detect automatically
        sprintf(cmd, "linkmon -l 60 -i %s -d -n %s -q %s", iface, pDNS, "aws.amazon.com");
    }
    system(cmd);
    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
#endif // HAS_LINKMON
#endif // HAS_SYSEYE
}

#if HAS_SYSEYE
#define CFG_PATH_LENGTH          512
#define SYSEYE_STATUS_OK         1
#define SYSEYE_NO_ETH            2
#define SYSEYE_NO_IP             3
#define SYSEYE_IP_CONFLICTED     4
#define SYSEYE_IP_GW_ERR         5
#define SYSEYE_HTTPS_PROXY_ERR   6
#define SYSEYE_DNS_ERR           7
#define SYSEYE_HTTPS_ERR         8
#define SYSEYE_HTTP_PROXY_ERR    11
#define SYSEYE_HTTP_ERR          12

JsonNode *get_linktest_result(int resultPath)
{
    struct seipc_t *handle=NULL;
    JsonNode *js_act;
    char cfgpath[CFG_PATH_LENGTH], *p;
    if (!(handle = seipc_create(__progname, SYSEYE_PATH))){
        return NULL;
    }

    snprintf(cfgpath, sizeof(cfgpath), "CFG_RAM/Actions[js_idx_key=%d]", resultPath);
    if ( (js_act = seipc_get_blk(handle, cfgpath)) == NULL){
        seipc_close(handle);
        return NULL;
    }
    seipc_close(handle);
    if (js_get_path_int(js_act, "key") != resultPath){
        js_free(js_act);
        return NULL;
    }
    return js_act;
}
#endif
int json_get_linktest(ResponseEntry *rep, struct json_object *jobj, int resultPath){
    ResponseStatus *res = rep->res;
#if HAS_SYSEYE
    JsonNode *js_act, *js_conn, *o;
    char *gx_str;
    int status_lan = 0, status_phylink = 0, status_arpdup = 0, status_icmp = 0;
    int status_wan = 0, status_dns, status_http, status_https = 0;

    struct json_object *conn, *devstatus, *localinfo, *internetinfo, *tmp;

    char iface[16];
    uint32_t ip, mask, gw;
    struct in_addr addr;
    char proto[7];
    char dhcp_ip_status[32];
    int proxy_type=0;
    int mesh_enabled=0;
    int is_noip;
    if (resultPath == -1 || (js_act = get_linktest_result(resultPath)) == NULL){
        RET_GEN_ERRORMSG(res, API_NO_PRODUCER, "No producer, must execute post linktest first");
    }
    js_conn = js_get_path(js_act, "Connectivity");
    json_foreach(o, js_conn){
        char *proto = js_get_path_str(o, "protocol");
        int status = js_get_path_int(o, "status");
	if (status == 0){
            debug_print("protocol:%s status:%d not ready\n", proto, status);
            js_free(js_act);
            RET_GEN_ERRORMSG(res, API_PROCESSING, "PROCESSING");
	}
    }

    status_phylink = js_get_path_int(js_act, "Connectivity[protocol=\"phylink\"]/status");
    status_arpdup = js_get_path_int(js_act, "Connectivity[protocol=\"arpdup\"]/status");
    status_icmp = js_get_path_int(js_act, "Connectivity[protocol=\"icmp\"]/status");
    status_dns = js_get_path_int(js_act, "Connectivity[protocol=\"dns\"]/status");
    status_http = js_get_path_int(js_act, "Connectivity[protocol=\"http\"]/status");
    status_https = js_get_path_int(js_act, "Connectivity[protocol=\"https\"]/status");
    debug_print("phylink:%d arpdup:%d icmp:%d dns:%d http:%d https:%d\n",
        status_phylink, status_arpdup, status_icmp, status_dns, status_http, status_https);

    // check lan status
    mesh_enabled = check_mesh_status();
    is_noip = check_noip_status();
    debug_print("mesh_enabled:%d is_noip:%d\n", mesh_enabled, is_noip);

    if (status_phylink != 1 && mesh_enabled != 1)
        status_lan = SYSEYE_NO_ETH;
    else if (is_noip == 1)
        status_lan = SYSEYE_NO_IP;
    else if (status_arpdup != 1)
        status_lan = SYSEYE_IP_CONFLICTED;
    else if (status_icmp != 1)
        status_lan = SYSEYE_IP_GW_ERR;
    else
        status_lan = SYSEYE_STATUS_OK;

    // check wan status
    proxy_type = get_http_proxy_type();
    if (status_dns != 1)
        status_wan = SYSEYE_DNS_ERR;
    else if (status_http != 1){
        if (proxy_type & PROXY_HTTP)
            status_wan = SYSEYE_HTTP_PROXY_ERR;
	else
            status_wan = SYSEYE_HTTP_ERR;
    }
    else if (status_https != 1){
        if (proxy_type & PROXY_HTTPS)
            status_wan = SYSEYE_HTTPS_PROXY_ERR;
	else
            status_wan = SYSEYE_HTTPS_ERR;
    } else 
        status_wan = SYSEYE_STATUS_OK;

    gx_str = js_to_str(js_get_path(js_act,"Connectivity"));
    if (!gx_str){
        js_free(js_act);
        RET_GEN_ERRORMSG(res, API_INTERNAL_ERROR, "json format parse error");
    }
    conn = json_tokener_parse(gx_str);
    if (gx_str)
        free(gx_str);
    js_free(js_act);

    devstatus = json_object_new_object();
    json_object_object_add(devstatus, "Connectivity", conn);

    // get LAN information: ip, mask, gw, proto
    if (get_if_waninfo(iface, &gw) == -1){
        debug_print("gateway got fail");
        strcpy(iface, "br-lan");
        gw=0;
    }
    if (get_if_addrinfo(iface, &ip, &mask) == -1){
        debug_print("ip mask got fail");
        ip = 0;
        mask = 0;
    }
    if (get_if_proto(proto) == -1){
        debug_print("proto got fail");
        strcpy(proto, "getfail");
    }
    localinfo = json_object_new_object();
    json_object_object_add(localinfo, "status", json_object_new_int(status_lan));
    addr.s_addr=ip;
    json_object_object_add(localinfo, "address", json_object_new_string(inet_ntoa(addr)));
    addr.s_addr=mask;
    json_object_object_add(localinfo, "mask", json_object_new_string(inet_ntoa(addr)));
    addr.s_addr=gw;
    json_object_object_add(localinfo, "gateway", json_object_new_string(inet_ntoa(addr)));
    json_object_object_add(localinfo, "proto", json_object_new_string(proto));
    json_object_object_add(localinfo, "mesh_enabled", json_object_new_int(mesh_enabled));
    if (!strcmp(proto, "dhcp") && get_dhcp_status(dhcp_ip_status) == 0){
        json_object_object_add(localinfo, "dhcp_addr_status", json_object_new_string_len(dhcp_ip_status, strlen(dhcp_ip_status)));
    }
    json_object_object_add(devstatus, "LocalInfo", localinfo);
    // get WAN information: ip, mask, gw, proto
    internetinfo = json_object_new_object();
    json_object_object_add(internetinfo, "status", json_object_new_int(status_wan));

    json_object_object_add(internetinfo, "http_proxy", json_object_new_int(proxy_type));

    json_object_object_add(devstatus, "InternetInfo", internetinfo);
    
    json_object_object_add(jobj, "DeviceStatus", devstatus);
#else //HAS_SYSEYE
#if HAS_LINKMON
    int status = 0, wan_status = -1, lan_status = -1, i;
    struct json_object *conn, *devstatus, *localinfo, *internetinfo, *tmp;
    const char *protocol;
    char iface[16];
    uint32_t ip, mask, gw;
    struct in_addr addr;
    char proto[7];
    char dhcp_ip_status[32];
    int proxy_type=0;

    lm_handle_t *lh = lm_open();
    if (lh == NULL || lh->ih == NULL){
        RET_GEN_ERRORMSG(res, API_NO_PRODUCER, "No producer, must execute post linktest first");
    }
    conn = lm_getjobj(lh, "Response[0]/Data/DeviceStatus/Connectivity");
    if (conn == NULL){
        lm_close(lh);
        RET_GEN_ERRORMSG(res, API_PROCESSING, "PROCESSING");
    }

    for (i = 0; i < json_object_array_length(conn); i++) {
        tmp = json_object_array_get_idx(conn, i);
        protocol = json_object_get_string(json_object_object_get(tmp, "protocol"));
        status = json_object_get_int(json_object_object_get(tmp, "status"));
        // simple state machine for status
        if (!strcmp(protocol, "phylink") ||
            !strcmp(protocol, "arpdup") ||
            !strcmp(protocol, "icmp")){
            if (lan_status == -1){
                if (status == 0) lan_status = 0;
                else if (status == 1) lan_status = 1;
                else lan_status = status;
        } else if (lan_status == 0){
            if (status == 0) lan_status = 0;
            else if (status == 1) lan_status = 0;
            else lan_status = status;
        } else if (lan_status == 1){
            if (status == 0) lan_status = 0;
            else if (status == 1) lan_status = 1;
            else lan_status = status;
        } else
            lan_status = status;
        }
        if (!strcmp(protocol, "http") ||
            !strcmp(protocol, "https") ||
            !strcmp(protocol, "dns")){
            if (wan_status == -1){
                if (status == 0) wan_status = 0;
                else if (status == 1) wan_status = 1;
                else wan_status = status;
            } else if (wan_status == 0){
                if (status == 0) wan_status = 0;
                else if (status == 1) wan_status = 0;
                else wan_status = status;
            } else if (wan_status == 1){
                if (status == 0) wan_status = 0;
                else if (status == 1) wan_status = 1;
                else wan_status = status;
            } else
                wan_status = status;
        }
    }
    devstatus = json_object_new_object();
    json_object_object_add(devstatus, "Connectivity", conn);
    // get LAN information: ip, mask, gw, proto
    if (get_if_waninfo(iface, &gw) == -1){
        debug_print("gateway got fail");
        strcpy(iface, "br-lan");
        gw=0;
    }

    if (get_if_addrinfo(iface, &ip, &mask) == -1){
        debug_print("ip mask got fail");
        ip = 0;
        mask = 0;
    }

    if (get_if_proto(proto) == -1){
        debug_print("proto got fail");
        strcpy(proto, "getfail");
    }
    //
    localinfo = json_object_new_object();
    json_object_object_add(localinfo, "status", json_object_new_int(lan_status));
    addr.s_addr=ip;
    json_object_object_add(localinfo, "address", json_object_new_string(inet_ntoa(addr)));
    addr.s_addr=mask;
    json_object_object_add(localinfo, "mask", json_object_new_string(inet_ntoa(addr)));
    addr.s_addr=gw;
    json_object_object_add(localinfo, "gateway", json_object_new_string(inet_ntoa(addr)));
    json_object_object_add(localinfo, "proto", json_object_new_string(proto));
    if (!strcmp(proto, "dhcp") && get_dhcp_status(dhcp_ip_status) == 0){
        json_object_object_add(localinfo, "dhcp_addr_status", json_object_new_string(dhcp_ip_status));
    }

    json_object_object_add(devstatus, "LocalInfo", localinfo);

    internetinfo = json_object_new_object();
    json_object_object_add(internetinfo, "status", json_object_new_int(wan_status));

    proxy_type = get_http_proxy_type();
    json_object_object_add(internetinfo, "http_proxy", json_object_new_int(proxy_type));

    json_object_object_add(devstatus, "InternetInfo", internetinfo);

    json_object_object_add(jobj, "DeviceStatus", devstatus);

    lm_close(lh);
#endif // HAS_LINKMON
#endif // HAS_SYSEYE
    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_set_ethernet(ResponseEntry *rep, char *query_str)
{
    char *mode=NULL, *p=NULL, *ip=NULL, *mask=NULL, *gateway=NULL, *pDns=NULL, *sDns=NULL, *ipv4_obj_str=NULL, *ipv6_obj_str=NULL;
    int mode_val = 0, vlanId = 0 ,prefix=0, linkloacl_val=0;
    bool linklocal_en=0;
    char *pDns6=NULL, *sDns6=NULL, *ip6_addr=NULL, *ip6_gateway=NULL, *static_mode=NULL, *hostname=NULL;
    bool lacp_mode = 0, vlanEn = 0;
    struct json_object *jobj=NULL;
    struct json_object *ipv4_obj = NULL;
    struct json_object *ipv6_obj = NULL;
    struct json_object *static_obj = NULL;
    ResponseStatus *res = rep->res;

    if(NULL != query_str)
    {
        if(jobj = jsonTokenerParseFromStack(rep, query_str))
        {

            senao_json_object_get_boolean(jobj, "lacp_mode", &lacp_mode);
            senao_json_object_get_boolean(jobj, "mgm_vlan_enable", &vlanEn);
            senao_json_object_get_integer(jobj, "mgm_vlan_id", &vlanId);
            senao_json_object_get_and_create_string(rep, jobj, "ipv4", &ipv4_obj_str);
            senao_json_object_get_and_create_string(rep, jobj, "mode", &mode);
            senao_json_object_get_and_create_string(rep, jobj, "ipv6", &ipv6_obj_str);
            senao_json_object_get_and_create_string(rep, jobj, "hostname", &hostname);
        }
    }
    if (strcmp(mode, "Static") == 0)
    {
        if((ipv4_obj = jsonTokenerParseFromStack(rep, ipv4_obj_str)))
        {
            senao_json_object_get_and_create_string(rep, ipv4_obj, "ip", &ip);
            senao_json_object_get_and_create_string(rep, ipv4_obj, "mask", &mask);
            senao_json_object_get_and_create_string(rep, ipv4_obj, "gateway", &gateway);
            senao_json_object_get_and_create_string(rep, ipv4_obj, "primary_dns", &pDns);
            senao_json_object_get_and_create_string(rep, ipv4_obj, "secondary_dns", &sDns);
        }
        if((ipv6_obj = jsonTokenerParseFromStack(rep, ipv6_obj_str)))
        {
            senao_json_object_get_boolean(ipv6_obj, "linklocal", &linklocal_en);
            senao_json_object_get_and_create_string(rep, ipv6_obj, "ip", &ip6_addr);
            senao_json_object_get_and_create_string(rep, ipv6_obj, "gateway", &ip6_gateway);
            senao_json_object_get_and_create_string(rep, ipv6_obj, "primary_dns", &pDns6);
            senao_json_object_get_and_create_string(rep, ipv6_obj, "secondary_dns", &sDns6);
            senao_json_object_get_integer(ipv6_obj, "prefix", &prefix);
        }
    }
    /* mode */
    for ( p = mode; *p; ++p) *p = tolower(*p);
    mode_val = ((strcmp(mode,"static") == 0)?0:1); 
    if (api_set_lan_proto_option(NETWORK_LAN_PROTO_OPTION, mode_val)) 
        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "MODE");

#if SUPPORT_IPV6_SETTING
    api_set_integer_option(NETWORK_LAN_ACCEPT_RA_OPTION, mode_val);
#endif

#if SUPPORT_ETHERNET_BONDING
    /* lacp_mode */
    if (api_set_lan_lacp_option(lacp_mode))
        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "LACP_MODE");
#else // set to no use config
    if (api_set_integer_option("network.lan.lacp_mode",lacp_mode))
        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "LACP_MODE");
#endif
    if (strcmp(mode, "static") == 0)
    {
        /* ip */
        if (api_set_lan_ipaddr_option(NETWORK_LAN_IPADDR_OPTION, ip, strlen(ip)))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "IP");

        /* mask */
        if (api_set_lan_netmask_option(NETWORK_LAN_NETMASK_OPTION, mask, strlen(mask)))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "MASK");

        /* gateway */
        if (api_set_lan_gateway_option(NETWORK_LAN_GATEWAY_OPTION, gateway, strlen(gateway)))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "GATEWAY");

        /* primary_dns */
        if (api_set_lan_dns_option(NETWORK_LAN_DNS_OPTION, 1, pDns, strlen(pDns)))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "PRIMARY DNS");

        /* secondary_dns */
        if (api_set_lan_dns_option(NETWORK_LAN_DNS_OPTION, 2, sDns, strlen(sDns)))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "SECONDARY DNS");
    }

    /* vlan enable */
    if (api_set_integer_option(NETWORK_SYSTEM_WLANVLANENABLE_OPTION, vlanEn))
        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "VLAN ENABLE");

    /* vlan id */
    if (vlanEn == true) 
    {
        if (api_set_integer_option(NETWORK_SYSTEM_MANAGEMENTVLANID_OPTION, vlanId))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "VLAN ID");
    }

    if (mode_val)
        linklocal_en = true ;

    if ( linklocal_en )
        linkloacl_val = 1 ;
#if SUPPORT_IPV6_SETTING
    /* link local */
    if (strcmp(mode, "static") == 0)
    {
        if (api_set_lan_ipv6_link_local_option(NETWORK_LAN_IPV6_LINK_LOCAL_OPTION, linkloacl_val))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "LINKLOCAL");
    }

    if ( !mode_val && !linklocal_en )
    {
        /* ipv6 addr */
        if (api_set_lan_ipv6_addr_option(NETWORK_LAN_IPV6_IPADDR_OPTION, ip6_addr, strlen(ip6_addr)))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "IPv6 ADDRESS");

        /* ipv6 prefix */
        if (api_set_lan_ipv6_subnet_prefix_length_option(NETWORK_LAN_IPV6_IPADDR_OPTION, prefix))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "IPv6 PREFIX");

        /* ipv6 gateway */
        if (api_set_lan_ipv6_gateway_option(NETWORK_LAN_IPV6_GATEWAY_OPTION, ip6_gateway, strlen(ip6_gateway)))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "IPv6 GATEWAY");

        /* primary_dns v6 */
        if (api_set_lan_dns_option(NETWORK_LAN_DNS_OPTION, 3, pDns6, strlen(pDns6)))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "IPv6 PRIMARY DNS");

        /* secondary_dns v6 */
        if (api_set_lan_dns_option(NETWORK_LAN_DNS_OPTION, 4, sDns6, strlen(sDns6)))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "IPv6 SECONDARY DNS");
    }
#endif

    if ( hostname )
    {
        api_set_system_hostname_option(NETWORK_LAN_HOSTNAME_OPTION, hostname, sizeof(hostname));
    }

#if SUPPORT_DHCP6C_SETTING
    api_set_integer_option(DHCP6C_BASIC_ENABLED_OPTION, mode_val);
#endif
    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);

}

int json_get_sys_controlled_info(ResponseEntry *rep, struct json_object *jobj)
{
    ResponseStatus *res = rep->res;
    int controlled = 0;

    api_get_integer_option("apcontroller.capwap.enable", &controlled);

    json_object_object_add(jobj, "controlled", json_object_new_boolean(controlled));

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_get_sys_info(ResponseEntry *rep, struct json_object *jobj)
{
    int cpu_load = 0, memUsage = 0, led_enable = 0, lan_speed = 0, lan_duplex = 0, systime_manual_en = 0, zone_number = 0, zone_auto_detect = 0, pw_changed = 0, pw_ignore = 0, mem_total_available = 0, mem_Buffers = 0, mem_Free = 0, mem_Cached = 0, i = 0, length = T_NUM_OF_ELEMENTS(api_timezone_table);
    int systime_year = 0, systime_month = 0, systime_day = 0, systime_hour = 0, systime_minute = 0;
    int  daylight_en = 0, daylight_start_month = 0, daylight_start_week, daylight_start_day = 0, daylight_start_hour = 0, daylight_end_month = 0, daylight_end_week, daylight_end_day = 0, daylight_end_hour = 0, auto_daylight_saving = 0;
    char *pt, ip[16]={0}, gateway[16]={0}, fwVersion[24]={0}, cpu[5]={0}, mem[5]={0}, memTotalAvailable[5]={0}, memBuffers[5]={0}, memFree[5]={0}, memCached[5]={0}, linkstat[16]={0}, sysCfg[16]={0}, deviceVersion[15]={0};
    char tmp[100]={0}, sysName[33]={0}, timezone[128]={0}, curtimezone[128]={0}, tzname[64] = {0}, *tzbuffer, *pch, uptime[64] = {0}, date[32] = {0}, time_mode[7] = {0}, systime_date[11] = {0}, systime_time[6] = {0}, current_date[11] = {0}, current_time[6] = {0};
    char ntp_server[256] = {0}, daylight_start_hour_string[6] = {0}, daylight_end_hour_string[6] = {0}, buf[256] = {0}, dhcp[256] = {0};
    char internet_status[8] = {0};
    char memBuffersSize[15]={0}, memFreeSize[15]={0}, memCachedSize[15]={0};
    int mem_total_available_size = 0, mem_capacity_size = 0, mem_usage_size = 0;
    struct json_object *jobj_sys_cfg = NULL, *jobj_time = NULL, *jobj_manual_set = NULL, *jobj_current_time = NULL, *jobj_auto_set = NULL, *jobj_daylight_saving = NULL;
    struct json_object *jobj_station_counts = NULL;
    struct json_object *jobj_24G = NULL;
#if SUPPORT_WLAN_5G_SETTING
    struct json_object *jobj_5G = NULL;
#if SUPPORT_WLAN_5G_2_SETTING
    struct json_object *jobj_5G2 = NULL;
#endif
#endif
#if 1
    char raw_uptime[64]={0}, raw_loadavg[64]={0};
#endif

    char month[12][4] = {"JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"};
    char weekday[7][4] = {"SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"};

    jobj_sys_cfg = json_object_new_object();
    jobj_time = json_object_new_object();
    jobj_current_time = json_object_new_object();
    jobj_manual_set = json_object_new_object();
    jobj_auto_set = json_object_new_object();
    jobj_daylight_saving = json_object_new_object();
    jobj_24G = json_object_new_object();
    jobj_station_counts = json_object_new_object();
#if SUPPORT_WLAN_5G_SETTING
    jobj_5G = json_object_new_object();
#if SUPPORT_WLAN_5G_2_SETTING
    jobj_5G2 = json_object_new_object();
#endif
#endif
    ResponseStatus *res = rep->res;

    char hostName[30] = {0}, modelName[30] = {0}, serial_num[30] = {0}, cur_ip[30] = {0}, mac[30] = {0}, mac_5g[30] = {0}, mac_24g[30] = {0} ;
    /* LAN_IP */
    api_get_lan_ipaddr_option(NETWORK_LAN_IPADDR_OPTION, ip, sizeof(ip));


    /* gateway_IP */
    api_get_string_option(NETWORK_LAN_PROTO_OPTION, buf, sizeof(buf));
    if (strcmp(buf,"dhcp") == 0) 
    {
        sys_interact(gateway, sizeof(gateway), "route -n| grep 'UG[ \t]'|awk '{ printf $2 }'");
    }
    else
    {
        api_get_lan_gateway_option(NETWORK_LAN_GATEWAY_OPTION, gateway, sizeof(gateway));
    }
    /* firmware_version */
    if(sys_check_file_existed("/etc/custom_version"))
    {
        if(sys_interact(fwVersion, sizeof(fwVersion), "cat /etc/custom_version | grep Firmware | awk \'BEGIN{FS= \" \"} {print $4}\'") > 0)
        {
            if ( (pt = strstr(fwVersion, "\n")) ) { /* delete tail "\n" */
                *pt = '\0';
            }
        }
        else
        {
            snprintf(fwVersion, sizeof(fwVersion), "%s", "unknown");
        }
    }
    else
    {
        if(sys_interact(fwVersion, sizeof(fwVersion), "cat /etc/version | grep Firmware | awk \'BEGIN{FS= \" \"} {print $4}\'") > 0)
        {
            if ( (pt = strstr(fwVersion, "\n")) ) { /* delete tail "\n" */
                *pt = '\0';
            }
        }
        else
        {
            snprintf(fwVersion, sizeof(fwVersion), "%s", "unknown");
        }
    }

    /* cpu_loading */
    //cpu_load = sys_get_cpu_cur_usage();
    cpu_load = sys_get_cpu_cur_usage_by_top();
    snprintf(cpu, sizeof(cpu), "%d%%", cpu_load);
    
    /* mem_usage */
    memUsage = sys_get_mem_usage();
    snprintf(mem, sizeof(mem), "%d%%", memUsage);

    /* mem_total_available */
    mem_total_available = sys_get_mem_total_available();
    snprintf(memTotalAvailable, sizeof(memTotalAvailable), "%d%%", mem_total_available);

    /* mem_Buffers */
    mem_Buffers = sys_get_mem_buffers();
    snprintf(memBuffers, sizeof(memBuffers), "%d%%", mem_Buffers);

    /* mem_buffers_size */
    sys_interact(memBuffersSize, sizeof(memBuffersSize), "cat /proc/meminfo | grep Buffers | awk '{print $2}'");
    if ( memBuffersSize[strlen(memBuffersSize)-1] == '\n' )
        memBuffersSize[strlen(memBuffersSize)-1] = 0;

    /* mem_Free */
    mem_Free = sys_get_mem_free();
    snprintf(memFree, sizeof(memFree), "%d%%", mem_Free);

    /* mem_free_size */
    sys_interact(memFreeSize, sizeof(memFreeSize), "cat /proc/meminfo | grep MemFree | awk '{print $2}'");
    if ( memFreeSize[strlen(memFreeSize)-1] == '\n' )
        memFreeSize[strlen(memFreeSize)-1] = 0;

    /* mem_Cached */
    mem_Cached = sys_get_mem_cached();
    snprintf(memCached, sizeof(memCached), "%d%%", mem_Cached);

    /* mem_cached_size */
    sys_interact(memCachedSize, sizeof(memCachedSize), "cat /proc/meminfo | grep Cached | grep -v Swap | awk '{print $2}'");
    if ( memCachedSize[strlen(memCachedSize)-1] == '\n' )
        memCachedSize[strlen(memCachedSize)-1] = 0;

    /* mem_capacity */
    mem_capacity_size = sys_get_mem_total();

    /* mem_total_available_size */
    mem_total_available_size = atoi(memBuffersSize) + atoi(memFreeSize) + atoi(memCachedSize);

    /* mem_usage_size */
    mem_usage_size = mem_capacity_size - atoi(memFreeSize);

    /* uptime */
    memset(uptime,0,sizeof(uptime));
    sys_get_uptime(uptime,sizeof(uptime));

    /* date */
    memset(date,0,sizeof(date));
    sys_interact(date, sizeof(date), "date");

    /* ethr_link_status */
    sys_get_link_status(linkstat, sizeof(linkstat));

    /* system_name */
    if (api_get_system_hostname_option(SYSTEM_SYSTEM_SYSTEMNAME_OPTION, sysName, sizeof(sysName)))
    {
        RET_GEN_ERRORMSG(res, API_INTERNAL_ERROR, "GET SYSTEM HOSTNAME");
    }

    /* model_name */
    if (api_get_string_option(SYSPRODUCTINFO_MODEL_MODELNAME_OPTION, modelName, sizeof(modelName)))
    {
        RET_GEN_ERRORMSG(res, API_INTERNAL_ERROR, "GET MODEL NAME");
    }

    /* device_version */
    if ( modelName[strlen(modelName)-2] == 'v')
    {
        sprintf(deviceVersion, "%c%s", modelName[strlen(modelName)-1], ".0");
    }
    else
    {
        strcpy(deviceVersion, "1.0");
    }

    /* lan_speed */
    sscanf(linkstat, "%d %d", &lan_speed, &lan_duplex);

    /* time_zone */
    api_get_integer_option(SYSTEM_SYSTEM_ZONENUMBER_OPTION, &zone_number);
    api_get_system_timezone_option(SYSTEM_SYSTEM_ZONENAME_OPTION, timezone, sizeof(timezone));

    /* time_zone auto detect*/
    api_get_integer_option(SYSTEM_SYSTEM_USE_LOCATIOIN_OPTION, &auto_daylight_saving);

    strcpy(curtimezone, "N/A");  //https://maps.googleapis.com is not available, so the zonename is incorrect
    api_get_integer_option("system.@system[0].zone_auto_detect", &zone_auto_detect);
    
    if (auto_daylight_saving == true)
    {
        strcpy(curtimezone, timezone);
    }
    else
    {
        if( zone_auto_detect == 1 )
        {
            sys_interact(tzname, sizeof(tzname), "uci get system.@system[0].zonename");
            if ( tzname[strlen(tzname)-1] == '\n' )
                tzname[strlen(tzname)-1] = 0;

            if ( strcmp(tzname, "auto")==0 || strcmp(tzname, "")==0 )
            {
                strcpy(curtimezone, "N/A");  //https://maps.googleapis.com is not available, so the zonename is incorrect
            }
            else
            {
                for( i=0 ; i < length; i++)
                {
                    tzbuffer = strstr(api_timezone_table[i].autotimezonename, tzname);
    
                    if ( tzbuffer != NULL)
                    {
                        strcpy(curtimezone, api_timezone_table[i].zonename);
                        break;
                    }
                }
            }
        }
        else
        {
            strcpy(curtimezone, api_timezone_table[zone_number].zonename);
        }
    }

    /* led_enable */
#if SUPPORT_LED_ONLY_STATUS
    api_get_integer_option(SYSTEM_SYSTEM_LED_STATUS_OPTION, &led_enable);
#else
    api_get_integer_option(SYSTEM_POWER_LED_DEFAULT_OPTION, &led_enable);
#endif
    /* first login */
    api_get_integer_option("tmp_wizard.wizard.pw_changed", &pw_changed);
    api_get_integer_option("tmp_wizard.wizard.pw_ignore", &pw_ignore);

    /* model name */
    api_get_system_hostname_option(SYSTEM_SYSTEM_HOSTNAME_OPTION, hostName, sizeof(hostName));
    
    /* serial number */
    memset(serial_num,0,sizeof(serial_num));
    sys_interact(serial_num, sizeof(serial_num), "setconfig -g 19");
    if ( strlen(serial_num) == 0 || strstr(serial_num,"00000000000000000000") )
    {
        memset(serial_num,0,sizeof(serial_num));
        sys_interact(serial_num, sizeof(serial_num), "setconfig -g 0");
    }
    if ( serial_num[strlen(serial_num)-1] == '\n' )
        serial_num[strlen(serial_num)-1] = 0;


    /* current lan ip */
    sys_interact(cur_ip, sizeof(cur_ip), "ifconfig br-lan |grep Bcast |awk {'printf $2'} |awk -F : {'printf $2'}");
    
    /* current mac */
    sys_interact(mac, sizeof(mac), "ifconfig br-lan |grep HWaddr |awk  {'printf $5'}");
#if SUPPORT_WLAN_24G_SETTING
    sys_interact(mac_24g, sizeof(mac_24g), "ifconfig wifi0 |grep HWaddr |awk  {'printf $5'}");
#endif
#if SUPPORT_WLAN_5G_SETTING
    /* current 5G mac */
    sys_interact(mac_5g, sizeof(mac_5g), "ifconfig wifi1 |grep HWaddr |awk  {'printf $5'}");
#endif

    /* current time */

    sys_interact(current_date, sizeof(current_date), "%s", "date +%Y-%m-%d");
    sys_interact(current_time, sizeof(current_time), "%s", "date +%H:%M");

    /* time_mode */
    api_get_integer_option(SYSTIME_MANUAL_ENABLE_OPTION, &systime_manual_en);
    memset(time_mode, 0, sizeof(time_mode));
    if ( systime_manual_en )
        sprintf(time_mode,"Manual");
    else
        sprintf(time_mode,"Auto");

    /* date */
    api_get_integer_option(SYSTIME_YEAR_ENABLE_OPTION, &systime_year);
    api_get_integer_option(SYSTIME_MONTH_ENABLE_OPTION, &systime_month);
    api_get_integer_option(SYSTIME_DAY_ENABLE_OPTION, &systime_day);
    memset(systime_date, 0, sizeof(systime_date));
    sprintf(systime_date, "%d/%d/%d", systime_year, systime_month, systime_day );

    /* time */
    api_get_integer_option(SYSTIME_HOUR_ENABLE_OPTION, &systime_hour);
    api_get_integer_option(SYSTIME_MINUTE_OPTION, &systime_minute);
    memset(systime_time, 0, sizeof(systime_time));

    if (systime_hour > 9 && systime_minute != 0)
    {
        sprintf(systime_time, "%d:%d", systime_hour, systime_minute);
    }
    else if (systime_hour <= 9 && systime_minute != 0)
    {
        sprintf(systime_time, "0%d:%d", systime_hour, systime_minute);
    }
    else if (systime_hour > 9 && systime_minute == 0)
    {
        sprintf(systime_time, "%d:00", systime_hour);
    }
    else
    {
        sprintf(systime_time, "0%d:00", systime_hour);
    }

    /* ntp_server */
    api_get_system_ntp_server_list(SYSTEM_NTP_SERVER_LIST, ntp_server, sizeof(ntp_server));

    /* daylight saving */
    api_get_integer_option(NTPCLIENT_DAYLIGHTSAVING_DAYLIGHTENABLE_OPTION, &daylight_en);
    api_get_integer_option(NTPCLIENT_DAYLIGHTSAVING_STARTMONTH_OPTION, &daylight_start_month);
    api_get_integer_option(NTPCLIENT_DAYLIGHTSAVING_STARTWEEK_OPTION, &daylight_start_week);
    api_get_integer_option(NTPCLIENT_DAYLIGHTSAVING_STARTDAY_OPTION, &daylight_start_day);
    api_get_integer_option(NTPCLIENT_DAYLIGHTSAVING_STARTHOUR_OPTION, &daylight_start_hour);
    api_get_integer_option(NTPCLIENT_DAYLIGHTSAVING_ENDMONTH_OPTION, &daylight_end_month);
    api_get_integer_option(NTPCLIENT_DAYLIGHTSAVING_ENDWEEK_OPTION, &daylight_end_week);
    api_get_integer_option(NTPCLIENT_DAYLIGHTSAVING_ENDDAY_OPTION, &daylight_end_day);
    api_get_integer_option(NTPCLIENT_DAYLIGHTSAVING_ENDHOUR_OPTION, &daylight_end_hour);
    sprintf(daylight_start_hour_string, "%d:00", daylight_start_hour );
    sprintf(daylight_end_hour_string, "%d:00", daylight_end_hour );

    /* internet_available */
    sys_interact(internet_status, sizeof(internet_status), "sh /sbin/checkInternet.sh");

#if 1
    sys_interact(raw_uptime, sizeof(raw_uptime), "cat /proc/uptime | tr -d '\n'");
    sys_interact(raw_loadavg, sizeof(raw_loadavg), "cat /proc/loadavg | tr -d '\n'");
#endif

    json_object_object_add(jobj, "gateway_ip", json_object_new_string(gateway));
    json_object_object_add(jobj, "firmware_version", json_object_new_string(fwVersion));
    json_object_object_add(jobj, "device_version", json_object_new_string(deviceVersion));
    json_object_object_add(jobj, "serial_number", json_object_new_string(serial_num));
    json_object_object_add(jobj, "cpu_loading", json_object_new_string(cpu));
    json_object_object_add(jobj, "mem_capacity", json_object_new_int(mem_capacity_size));
    json_object_object_add(jobj, "mem_usage", json_object_new_string(mem));
    json_object_object_add(jobj, "mem_usage_size", json_object_new_int(mem_usage_size));
    json_object_object_add(jobj, "mem_total_available", json_object_new_string(memTotalAvailable));
    json_object_object_add(jobj, "mem_total_available_size", json_object_new_int(mem_total_available_size));
    json_object_object_add(jobj, "mem_buffers", json_object_new_string(memBuffers));
    json_object_object_add(jobj, "mem_buffers_size", json_object_new_int(atoi(memBuffersSize)));
    json_object_object_add(jobj, "mem_free", json_object_new_string(memFree));
    json_object_object_add(jobj, "mem_free_size", json_object_new_int(atoi(memFreeSize)));
    json_object_object_add(jobj, "mem_cached", json_object_new_string(memCached));
    json_object_object_add(jobj, "mem_cached_size", json_object_new_int(atoi(memCachedSize)));
    json_object_object_add(jobj, "uptime", json_object_new_string(uptime));
#if 1
    json_object_object_add(jobj, "raw_proc_uptime", json_object_new_string(raw_uptime));
    json_object_object_add(jobj, "raw_proc_loadavg", json_object_new_string(raw_loadavg));
    json_object_object_add(jobj, "power_souce", json_object_new_int(0));
#endif
    json_object_object_add(jobj, "date", json_object_new_string(date));
    json_object_object_add(jobj, "ethr_link_status", json_object_new_string(linkstat));
    json_object_object_add(jobj, "lan_speed", json_object_new_int(lan_speed));
    json_object_object_add(jobj, "ip_address", json_object_new_string(cur_ip));
    json_object_object_add(jobj, "mac_address", json_object_new_string(mac));
#if SUPPORT_WLAN_24G_SETTING
    json_object_object_add(jobj, "mac_24g_address", json_object_new_string(mac_24g));
#endif
#if SUPPORT_WLAN_5G_SETTING
    json_object_object_add(jobj, "mac_5g_address", json_object_new_string(mac_5g));
#endif

    json_object_object_add(jobj_sys_cfg, "device_name", json_object_new_string(sysName));
    json_object_object_add(jobj_sys_cfg, "model", json_object_new_string(modelName));

    json_object_object_add(jobj_current_time, "date", json_object_new_string(current_date));
    json_object_object_add(jobj_current_time, "time", json_object_new_string(current_time));
    json_object_object_add(jobj_time, "current_time", jobj_current_time);
    json_object_object_add(jobj_time, "mode", json_object_new_string(time_mode));
    json_object_object_add(jobj_manual_set, "date", json_object_new_string(systime_date));
    json_object_object_add(jobj_manual_set, "time", json_object_new_string(systime_time));
    json_object_object_add(jobj_time, "Manual_set", jobj_manual_set);

    json_object_object_add(jobj_auto_set, "ntp_server", json_object_new_string(ntp_server));
    json_object_object_add(jobj_time, "Auto_set", jobj_auto_set);
    
    json_object_object_add(jobj_time, "auto_daylight_saving", json_object_new_boolean(auto_daylight_saving));
    if ( auto_daylight_saving == true )
    {
        json_object_object_add(jobj_time, "time_zone", json_object_new_string(timezone));
    }
    else
    {
        json_object_object_add(jobj_time, "time_zone", json_object_new_string(api_timezone_table[zone_number].zonename));
    }
    json_object_object_add(jobj_time, "cur_time_zone", json_object_new_string(curtimezone));
    json_object_object_add(jobj_time, "time_zone_auto_detect", json_object_new_boolean(zone_auto_detect));

    json_object_object_add(jobj_daylight_saving, "enable", json_object_new_boolean(daylight_en));
    json_object_object_add(jobj_daylight_saving, "start_month", json_object_new_string(month[daylight_start_month-1]));
    json_object_object_add(jobj_daylight_saving, "start_week", json_object_new_int(daylight_start_week));
    json_object_object_add(jobj_daylight_saving, "start_day", json_object_new_string(weekday[daylight_start_day]));
    json_object_object_add(jobj_daylight_saving, "start_time", json_object_new_string(daylight_start_hour_string));
    json_object_object_add(jobj_daylight_saving, "end_month", json_object_new_string(month[daylight_end_month-1]));
    json_object_object_add(jobj_daylight_saving, "end_week", json_object_new_int(daylight_end_week));
    json_object_object_add(jobj_daylight_saving, "end_day", json_object_new_string(weekday[daylight_end_day]));
    json_object_object_add(jobj_daylight_saving, "end_time", json_object_new_string(daylight_end_hour_string));
    json_object_object_add(jobj_time, "daylight_saving", jobj_daylight_saving);

    json_object_object_add(jobj_sys_cfg, "time", jobj_time);

#if SUPPORT_LED_ONLY_STATUS
    json_object_object_add(jobj_sys_cfg, "led_enable", json_object_new_boolean(led_enable));
#else
    json_object_object_add(jobj_sys_cfg, "led_enable", json_object_new_boolean(!led_enable));
#endif

#if !SUPPORT_SWOS_FUNCTION
    json_object_object_add(jobj_sys_cfg, "pw_changed", json_object_new_boolean(pw_changed));
    json_object_object_add(jobj_sys_cfg, "pw_ignore", json_object_new_boolean(pw_ignore));
#endif

    json_object_object_add(jobj, "sys_cfg", jobj_sys_cfg);

    json_object_object_add(jobj, "product_name", json_object_new_string(hostName));
    json_object_object_add(jobj, "internet_available", (strstr(internet_status,"Online"))?json_object_new_boolean(true):json_object_new_boolean(false));

    json_object_object_add(jobj_24G, "counts", json_object_new_int(get_station_counts(0)));
    json_object_object_add(jobj_station_counts, "2_4G", jobj_24G);
#if SUPPORT_WLAN_5G_SETTING
    json_object_object_add(jobj_5G, "counts", json_object_new_int(get_station_counts(1)));
    json_object_object_add(jobj_station_counts, "5G", jobj_5G);
#if SUPPORT_WLAN_5G_2_SETTING
    json_object_object_add(jobj_5G2, "counts", json_object_new_int(get_station_counts(2)));
    json_object_object_add(jobj_station_counts, "5G-2", jobj_5G2);
#endif
#endif

    json_object_object_add(jobj, "station_counts", jobj_station_counts);

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_set_sys_info(ResponseEntry *rep, char *query_str)
{
    int ret = 0, i = 0, length = T_NUM_OF_ELEMENTS(api_timezone_table), systime_manual_en = 0, year = 0, month = 0, day = 0, hour = 0, minute = 0, daylight_saving_start_week = 0, daylight_saving_end_week = 0;
    bool  daylight_saving_en = false, led_enable = false, time_zone_auto_detect = false, pw_changed = false, pw_ignore = false, auto_daylight_saving = false;
    char *sysName=NULL, *timezone=NULL, tmp[100]={0}, *time_mode=NULL, *date=NULL, *time=NULL, *ntp_server=NULL, *pch;
    char *jobj_time_string=NULL, *jobj_manual_set_string=NULL, *jobj_auto_set_string=NULL, *jobj_daylight_saving_string=NULL;
    char *daylight_saving_start_month=NULL, *daylight_saving_start_day=NULL, *daylight_saving_start_time=NULL, *daylight_saving_end_month=NULL, *daylight_saving_end_day=NULL, *daylight_saving_end_time=NULL;
    struct json_object *jobj = NULL, *jobj_time = NULL, *jobj_manual_set = NULL, *jobj_auto_set = NULL, *jobj_daylight_saving = NULL;

    char month_ary[12][4] = {"JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"};
    char weekday[7][4] = {"SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"};
    char buf[256] = {0};
    ResponseStatus *res = rep->res;

    if(NULL != query_str)
    {
        if((jobj = jsonTokenerParseFromStack(rep, query_str)))
        {
            senao_json_object_get_and_create_string(rep, jobj, "device_name", &sysName);

            /* device_name */
#if SUPPORT_NETGEAR_FUNCTION
            if (!api_check_string_length(sysName, 1, 15) || !regxMatch("^.*[a-zA-Z]+.*$", sysName) ||
                regxMatch("^[\\-]", sysName) || regxMatch("[\\-]$", sysName) ||
                !regxMatch("^([a-zA-Z0-9\\-]+)$", sysName))
            {
                //debug_print("\n%s[%d]===> netgear ap name fail \n", __FUNCTION__, __LINE__);
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "DEVICE NAME");
            }
#endif
            if (api_set_system_hostname_option(SYSTEM_SYSTEM_SYSTEMNAME_OPTION, sysName, sizeof(sysName)))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "DEVICE NAME");

            api_set_system_hostname_option(DHCP_DNSMASQ_DOMAIN_OPTION, sysName, sizeof(sysName));
            api_set_system_hostname_option(NETWORK_LAN_HOSTNAME_OPTION, sysName, sizeof(sysName));
            api_set_system_hostname_option(SNMPD_SYSTEM_SYSNAME_OPTION, sysName, sizeof(sysName));

            senao_json_object_get_and_create_string(rep, jobj, "time", &jobj_time_string);
            senao_json_object_get_boolean(jobj, "led_enable", &led_enable);
            senao_json_object_get_boolean(jobj, "pw_changed", &pw_changed);
            senao_json_object_get_boolean(jobj, "pw_ignore", &pw_ignore);

            api_set_integer_option("tmp_wizard.wizard.pw_changed", pw_changed?1:0);
            api_set_integer_option("tmp_wizard.wizard.pw_ignore", pw_ignore?1:0);

            if((jobj_time = jsonTokenerParseFromStack(rep, jobj_time_string)))
            {
                senao_json_object_get_and_create_string(rep, jobj_time, "mode", &time_mode);

                if ( strcasecmp(time_mode, "Manual") == 0 )
                {
                    systime_manual_en = 1;
                    senao_json_object_get_and_create_string(rep, jobj_time, "Manual_set", &jobj_manual_set_string);

                    if((jobj_manual_set = jsonTokenerParseFromStack(rep, jobj_manual_set_string)))
                    {
                        senao_json_object_get_and_create_string(rep, jobj_manual_set, "date", &date);
                        senao_json_object_get_and_create_string(rep, jobj_manual_set, "time", &time);

                        if ( sscanf(date, "%d/%d/%d", &year, &month, &day) != 3 )
                            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "DATE");

                        if ( sscanf(time, "%d:%d", &hour, &minute) != 2 )
                            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "TIME");

                        api_set_system_ntp_enable_server_option(SYSTEM_NTP_ENABLE_SERVER_OPTION, 0);

                        ret = API_RC_SUCCESS ;
                        ret |= api_set_integer_option(SYSTIME_YEAR_ENABLE_OPTION, year);
                        ret |= api_set_integer_option(SYSTIME_MONTH_ENABLE_OPTION, month);
                        ret |= api_set_integer_option(SYSTIME_DAY_ENABLE_OPTION, day);

                        if ( ret != API_RC_SUCCESS )
                            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "DATE");

                        ret = API_RC_SUCCESS ;
                        ret |= api_set_integer_option(SYSTIME_HOUR_ENABLE_OPTION, hour);
                        ret |= api_set_integer_option(SYSTIME_MINUTE_OPTION, minute);

                        if ( ret != API_RC_SUCCESS )
                            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "TIME");
                    }
                }
                else
                {
                    systime_manual_en = 0;
                    senao_json_object_get_and_create_string(rep, jobj_time, "Auto_set", &jobj_auto_set_string);

                    if((jobj_auto_set = jsonTokenerParseFromStack(rep, jobj_auto_set_string)))
                    {
                        senao_json_object_get_and_create_string(rep, jobj_auto_set, "ntp_server", &ntp_server);

                        api_set_system_ntp_enable_server_option(SYSTEM_NTP_ENABLE_SERVER_OPTION, 1);

                        if ( api_set_system_ntp_server_list(SYSTEM_NTP_SERVER_LIST, ntp_server, sizeof(ntp_server)) )
                            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "NTP SERVER");
                    }
                }

                /* time mode */
                if (api_set_integer_option(SYSTIME_MANUAL_ENABLE_OPTION, systime_manual_en))
                    RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "TIME MODE");

                /* time_zone */
                senao_json_object_get_boolean(jobj_time, "auto_daylight_saving", &auto_daylight_saving );
                api_set_integer_option(SYSTEM_SYSTEM_USE_LOCATIOIN_OPTION, auto_daylight_saving?1:0);//default is false

                senao_json_object_get_and_create_string(rep, jobj_time, "time_zone", &timezone);

                if ( auto_daylight_saving == true)
                {
                    ret |= api_set_string_option(SYSTEM_SYSTEM_ZONENAME_OPTION, timezone, sizeof(timezone));
                    if ( ret != API_RC_SUCCESS )
                        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "TIME ZONE");
                }
                else
                {
                    for( i=0 ; i < length; i++)
                    {
                        if (strcasecmp(api_timezone_table[i].zonename, timezone) == 0)
                        {
                            ret = API_RC_SUCCESS ;
                            ret |= api_set_string_option(SYSTEM_SYSTEM_ZONENAME_OPTION, api_timezone_table[i].zonename, sizeof(api_timezone_table[i].zonename));
                            ret |= api_set_string_option(SYSTEM_SYSTEM_TIMEZONE_OPTION, api_timezone_table[i].timezone, sizeof(api_timezone_table[i].timezone));
                            ret |= api_set_integer_option(SYSTEM_SYSTEM_ZONENUMBER_OPTION, i);

                            if ( ret != API_RC_SUCCESS )
                                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "TIME ZONE");

                            break;
                        }
                    }
                    if ( i == length )
                        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "TIME ZONE");
                }

                /* time_zone auto detect */
                // senao_json_object_get_boolean(jobj_time, "time_zone_auto_detect", &time_zone_auto_detect);
                api_set_integer_option("system.@system[0].zone_auto_detect", time_zone_auto_detect?1:0);//default is false

                // if ( time_zone_auto_detect == true)
                // {
                //     api_set_string_option(SYSTEM_SYSTEM_ZONENAME_OPTION, "auto", 4);
                // }

                /* daylight_saving */
                senao_json_object_get_and_create_string(rep, jobj_time, "daylight_saving", &jobj_daylight_saving_string);

                if((jobj_daylight_saving = jsonTokenerParseFromStack(rep, jobj_daylight_saving_string)))
                {
                    senao_json_object_get_boolean(jobj_daylight_saving, "enable", &daylight_saving_en );

                    senao_json_object_get_and_create_string(rep, jobj_daylight_saving, "start_month", &daylight_saving_start_month);
                    senao_json_object_get_integer(jobj_daylight_saving, "start_week", &daylight_saving_start_week);
                    senao_json_object_get_and_create_string(rep, jobj_daylight_saving, "start_day", &daylight_saving_start_day);
                    senao_json_object_get_and_create_string(rep, jobj_daylight_saving, "start_time", &daylight_saving_start_time);

                    senao_json_object_get_and_create_string(rep, jobj_daylight_saving, "end_month", &daylight_saving_end_month);
                    senao_json_object_get_integer(jobj_daylight_saving, "end_week", &daylight_saving_end_week);
                    senao_json_object_get_and_create_string(rep, jobj_daylight_saving, "end_day", &daylight_saving_end_day);
                    senao_json_object_get_and_create_string(rep, jobj_daylight_saving, "end_time", &daylight_saving_end_time);

                    api_set_system_ntp_day_light_saving_enable_option(NTPCLIENT_DAYLIGHTSAVING_DAYLIGHTENABLE_OPTION, (daylight_saving_en)?1:0);

                    if (auto_daylight_saving == true)
                        daylight_saving_en = false;

                    if (daylight_saving_en == true) 
                    {
                        for (i = 0; i < 12; i++)
                        {
                            if ( strcasecmp(daylight_saving_start_month, month_ary[i] ) == 0 )
                            {
                                break;
                            }
                        }

                        if ( api_set_system_ntp_day_light_saving_month_option(NTPCLIENT_DAYLIGHTSAVING_STARTMONTH_OPTION, i+1) != API_RC_SUCCESS )
                            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "DAYLIGHTSAVING STARTMONTH");

                        if ( api_set_system_ntp_day_light_saving_week_option(NTPCLIENT_DAYLIGHTSAVING_STARTWEEK_OPTION, daylight_saving_start_week) != API_RC_SUCCESS )
                            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "DAYLIGHTSAVING STARTWEEK");

                        for ( i = 0 ; i < 7 ; i++ )
                        {
                            if ( strcasecmp(daylight_saving_start_day, weekday[i] ) == 0 )
                            {
                                break;
                            }
                        }

                        if ( api_set_system_ntp_day_light_saving_day_option(NTPCLIENT_DAYLIGHTSAVING_STARTDAY_OPTION, i ) != API_RC_SUCCESS )
                            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "DAYLIGHTSAVING STARTDAY");

                        if ( sscanf(daylight_saving_start_time, "%d:", &hour) != 1 )
                            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "DAYLIGHTSAVING STARTIME");

                        if ( api_set_system_ntp_day_light_saving_hour_option(NTPCLIENT_DAYLIGHTSAVING_STARTHOUR_OPTION, hour) != API_RC_SUCCESS )
                            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "DAYLIGHTSAVING STARTTIME");

                        for ( i = 0 ; i < 12 ; i++ )
                        {
                            if ( strcasecmp(daylight_saving_end_month, month_ary[i] ) == 0 )
                            {
                                break;
                            }
                        }

                        if ( api_set_system_ntp_day_light_saving_month_option(NTPCLIENT_DAYLIGHTSAVING_ENDMONTH_OPTION, i+1 ) != API_RC_SUCCESS )
                            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "DAYLIGHTSAVING ENDMONTH");

                        if ( api_set_system_ntp_day_light_saving_week_option(NTPCLIENT_DAYLIGHTSAVING_ENDWEEK_OPTION, daylight_saving_end_week) != API_RC_SUCCESS )
                            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "DAYLIGHTSAVING ENDWEEK");

                        for ( i = 0 ; i < 7 ; i++ )
                        {
                            if ( strcasecmp(daylight_saving_end_day, weekday[i] ) == 0 )
                            {
                                break;
                            }
                        }

                        if ( api_set_system_ntp_day_light_saving_day_option(NTPCLIENT_DAYLIGHTSAVING_ENDDAY_OPTION, i ) != API_RC_SUCCESS )
                            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "DAYLIGHTSAVING ENDDAY");

                        if ( sscanf(daylight_saving_end_time, "%d:", &hour) != 1 )
                            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "DAYLIGHTSAVING ENDTIME");

                        if ( api_set_system_ntp_day_light_saving_hour_option(NTPCLIENT_DAYLIGHTSAVING_ENDHOUR_OPTION, hour) != API_RC_SUCCESS )
                            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "DAYLIGHTSAVING ENDTIME");
                    }
                }
            }

            /* led_enable */
#if SUPPORT_LED_ONLY_STATUS
            api_set_integer_option(SYSTEM_SYSTEM_LED_STATUS_OPTION, led_enable?1:0);
#else
            api_set_integer_option(SYSTEM_POWER_LED_DEFAULT_OPTION, led_enable?0:1);
            api_set_integer_option(SYSTEM_LAN1_LED_DEFAULT_OPTION, led_enable?0:1);
            api_set_integer_option(SYSTEM_WIFI0_LED_DEFAULT_OPTION, led_enable?0:1);
            api_set_integer_option(SYSTEM_WIFI1_LED_DEFAULT_OPTION, led_enable?0:1);
            api_set_integer_option("system.mesh_led.default", led_enable?0:1);
#endif

        }
    }
    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_fw_upgrade(ResponseEntry *rep, char *query_str){

    char *upgrade_url=NULL;
    bool doReset = 0;
    struct json_object *jobj;
    ResponseStatus *res = rep->res;

    if(NULL != query_str)
    {
        if((jobj = jsonTokenerParseFromStack(rep, query_str)))
        {
            senao_json_object_get_and_create_string(rep, jobj, "upgrade_url", &upgrade_url);
            senao_json_object_get_boolean(jobj, "do_reset_after_upgrade", &doReset);
        }
    }
    int led, senaowrt;

    api_get_integer_option("functionlist.functionlist.SUPPORT_LED_MODULE_NAME", &led);
    api_get_integer_option("functionlist.functionlist.SUPPORT_SENAOWRT_IMAGE", &senaowrt);

    if (led == 1) 
    {
        if (senaowrt == 1)
        {
            system("sleep 1; killall dropbear uhttpd lighttpd senao-lsp; sleep 1; echo timer > /sys/class/leds/power1_led/trigger;/etc/fwupgrade.sh /tmp/firmware.img");
        }
        else
        {
            system("sleep 1; killall dropbear uhttpd lighttpd senao-lsp; sleep 1; echo timer > /sys/class/leds/power1_led/trigger;/sbin/sysupgrade /tmp/firmware.img");
        }
    }
    else
    {
        if (senaowrt == 1)
        {
            system("sleep 1; killall dropbear uhttpd lighttpd senao-lsp; sleep 1; echo timer > /sys/class/leds/power/trigger;/etc/fwupgrade.sh /tmp/firmware.img");
        }
        else
        {
            system("sleep 1; killall dropbear uhttpd lighttpd senao-lsp; sleep 1; echo timer > /sys/class/leds/power/trigger;/sbin/sysupgrade /tmp/firmware.img");
        }
    }

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);

}

int json_sys_apply(ResponseEntry *rep, char *query_str)
{
    ResponseStatus *res = rep->res;

#if SUPPORT_SYSTEM_LOG
    system("/usr/sbin/print_change_log.sh");
#endif

#if SUPPORT_AP_RP_SETUP_WIZARD
    char opmode[32] = {0};
    sys_interact(opmode, sizeof(opmode), "uci changes |grep opmode");
#endif

#if SUPPORT_LIBCLOUDAP_SETTING
    char lsp_mod[4] = {0};
    sys_interact(lsp_mod, sizeof(lsp_mod), "uci changes | wc -l");
    lsp_mod[strcspn(lsp_mod, "\n")] = '\0';
    if (strcmp(lsp_mod, "0"))
    {
        system("uci set lsp_sync.lsp_sync.modified_time=`date +%s`");
        system("uci set lsp_sync.lsp_sync.config_version=`uci get ezmcloud.ezmcloud.config_version`");
        system("uci commit lsp_sync");
    }
#endif

    if ( access( "/usr/bin/cfg_failsafe_save.sh", F_OK ) != -1 )
        system("( /sbin/luci-reload auto ; /usr/bin/cfg_failsafe_save.sh ) &");
    else
        system("/sbin/luci-reload auto &");

#if SUPPORT_AP_RP_SETUP_WIZARD
    if (strcmp(opmode, "") !=0) 
    {
        system("reboot &");
    }
#endif
    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_get_ezmcloud_info(ResponseEntry *rep, struct json_object *jobj){

    char modified_time[32] = {0}, web_url[128] = {0}, created_time[32] = {0}, secret[33] = {0}, version[12] = {0}, cloud_connect_status[8] = {0}, cloud_status[8] = {0};
    ResponseStatus *res = rep->res;

    memset(modified_time,0,sizeof(modified_time));
    memset(web_url,0,sizeof(web_url));
    memset(created_time,0,sizeof(created_time));
    memset(secret,0,sizeof(secret));

    // api_get_string_option(EZMCLOUD_MODIFIEDTIME_OPTION, modified_time, sizeof(modified_time));
    sys_interact(modified_time, sizeof(modified_time), "cat /var/run/ezmcloud/checkin_success_time");

    api_get_string_option(EZMCLOUD_WEBURL_OPTION, web_url, sizeof(web_url));
    api_get_string_option(EZMCLOUD_CREATEDTIME_OPTION, created_time, sizeof(created_time));
    api_get_string_option(EZMCLOUD_SECRET_OPTION, secret, sizeof(secret));

    sys_interact(version, sizeof(version), "cat /etc/version_cloud | tr -d \"\n\"");

    sys_interact(cloud_connect_status, sizeof(cloud_connect_status), "cat /var/run/ezmcloud/server/chicken_status | tr -d \"\n\"");

    if(sys_check_file_existed("/var/run/ezmcloud/server/cloud_status"))
    {
        sys_interact(cloud_status, sizeof(cloud_status), "cat /var/run/ezmcloud/server/cloud_status | tr -d \"\n\"");
        json_object_object_add(jobj, "cloud_status", json_object_new_int(atoi(cloud_status)));
    }

    json_object_object_add(jobj, "modified_time", json_object_new_string(modified_time));
    json_object_object_add(jobj, "cloud_connect", json_object_new_string(cloud_connect_status));
    json_object_object_add(jobj, "web_url", json_object_new_string(web_url));
    json_object_object_add(jobj, "reg_status", json_object_new_int(strlen(secret)?1:0));
    json_object_object_add(jobj, "created_time", json_object_new_string(created_time));
    json_object_object_add(jobj, "cloud_version", json_object_new_string(version));

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}
int json_get_net_proxy_settings(ResponseEntry *rep, struct json_object *jobj){

    char ip[128] = {0}, username[17] = {0}, password[17] = {0}, use_profile[200] = {0}, exclude_subnet[200] = {0} ;
    char proxy1_enable[10] = {0}, proxy2_enable[10] = {0};
    int port, auth;

    ResponseStatus *res = rep->res;
    struct json_object *jobj_proxy1;
    struct json_object *jobj_proxy2;
    jobj_proxy1 = json_object_new_object();
    jobj_proxy2 = json_object_new_object();
    api_get_string_option(REDSOCKS2_ETHERNET_PROXY_USE_PROFILE, use_profile, sizeof (use_profile));

    sscanf(use_profile, "%s %s", proxy1_enable, proxy2_enable);

    // http
    api_get_redsocks_proxy_ip_option_by_sectionname(REDSOCKS2_PROXY2_IP, ip, sizeof(ip));
    api_get_redsocks_proxy_port_option_by_sectionname(REDSOCKS2_PROXY2_PORT, &port);
    api_get_redsocks_proxy_authorization_option_by_sectionname(REDSOCKS2_PROXY2_AUTHORIZATION, &auth);
    api_get_redsocks_proxy_username_option_by_sectionname(REDSOCKS2_PROXY2_USERNAME, username, sizeof(ip));
    api_get_redsocks_proxy_password_option_by_sectionname(REDSOCKS2_PROXY2_PASSWORD, password, sizeof(ip));

    json_object_object_add(jobj_proxy1, "enable", json_object_new_boolean((strcmp(proxy2_enable, "none")==0)?0:1));
    json_object_object_add(jobj_proxy1, "ip", json_object_new_string(ip));
    json_object_object_add(jobj_proxy1, "port", json_object_new_int(port));
    json_object_object_add(jobj_proxy1, "is_auth_en", json_object_new_boolean(auth));
    json_object_object_add(jobj_proxy1, "username", json_object_new_string(username));
    json_object_object_add(jobj_proxy1, "password", json_object_new_string(password));

    // https
    json_object_object_add(jobj_proxy2, "enable", json_object_new_boolean((strcmp(proxy1_enable, "none")==0)?0:1));
    api_get_redsocks_proxy_ip_option_by_sectionname(REDSOCKS2_PROXY1_IP, ip, sizeof(ip));
    api_get_redsocks_proxy_port_option_by_sectionname(REDSOCKS2_PROXY1_PORT, &port);
    api_get_redsocks_proxy_authorization_option_by_sectionname(REDSOCKS2_PROXY1_AUTHORIZATION, &auth);
    api_get_redsocks_proxy_username_option_by_sectionname(REDSOCKS2_PROXY1_USERNAME, username, sizeof(ip));
    api_get_redsocks_proxy_password_option_by_sectionname(REDSOCKS2_PROXY1_PASSWORD, password, sizeof(ip));

    json_object_object_add(jobj_proxy2, "ip", json_object_new_string(ip));
    json_object_object_add(jobj_proxy2, "port", json_object_new_int(port));
    json_object_object_add(jobj_proxy2, "is_auth_en", json_object_new_boolean(auth));
    json_object_object_add(jobj_proxy2, "username", json_object_new_string(username));
    json_object_object_add(jobj_proxy2, "password", json_object_new_string(password));


    api_get_string_option(REDSOCKS2_ETHERNET_EXCLUDE_SUBNET, exclude_subnet, sizeof (exclude_subnet));

    json_object_object_add(jobj, "http", jobj_proxy1);
    json_object_object_add(jobj, "https", jobj_proxy2);

    json_object_object_add(jobj, "exclude_subnet", json_object_new_string(exclude_subnet));

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}
int json_set_net_proxy_settings(ResponseEntry *rep, char *query_str){

    char *ip=NULL, *username=NULL, *password=NULL;
    int port;
    bool is_auth_en = false;
    bool enable = false;
    char *use_profile=NULL;
    char *exclude_subnet=NULL;
    char buf[32] = {0};
    int value_num = 0, i = 0;
    struct json_object *jobj;
    ResponseStatus *res = rep->res;
    struct json_object *http_obj = NULL;
    struct json_object *https_obj = NULL;
    char *http_obj_str=NULL, *https_obj_str=NULL;

    if(NULL != query_str)
    {
        if(jobj = jsonTokenerParseFromStack(rep, query_str))
        {
            senao_json_object_get_and_create_string(rep, jobj, "http", &http_obj_str);
            senao_json_object_get_and_create_string(rep, jobj, "https", &https_obj_str);
            senao_json_object_get_and_create_string(rep, jobj, "exclude_subnet", &exclude_subnet);
        }
        api_delete_option(REDSOCKS2_ETHERNET_PROXY_USE_PROFILE, "");
        api_delete_option(REDSOCKS2_ETHERNET_EXCLUDE_SUBNET, "");

        if((https_obj = jsonTokenerParseFromStack(rep, https_obj_str)))
        {
            senao_json_object_get_boolean(https_obj, "enable", &enable);
            senao_json_object_get_and_create_string(rep, https_obj, "ip", &ip);
            senao_json_object_get_integer(https_obj, "port", &port);
            senao_json_object_get_boolean(https_obj, "is_auth_en", &is_auth_en);
            senao_json_object_get_and_create_string(rep, https_obj, "username", &username);
            senao_json_object_get_and_create_string(rep, https_obj, "password", &password);
        }
        if (enable == true)
        {
            api_add_list(REDSOCKS2_ETHERNET_PROXY_USE_PROFILE, "proxy1", strlen("proxy1"));
            if (api_set_redsocks_proxy_ip_https_url_option_by_sectionname(REDSOCKS2_PROXY1_IP, ip, sizeof(ip)))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "IP");
            if (api_set_redsocks_proxy_port_option_by_sectionname(REDSOCKS2_PROXY1_PORT, port))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "PORT");

            if (api_set_redsocks_proxy_authorization_option_by_sectionname(REDSOCKS2_PROXY1_AUTHORIZATION, is_auth_en))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "IS_AUTH_EN");

            if (api_set_redsocks_proxy_username_option_by_sectionname(REDSOCKS2_PROXY1_USERNAME, username, sizeof(username)))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "USERNAME");

            if (api_set_redsocks_proxy_password_option_by_sectionname(REDSOCKS2_PROXY1_PASSWORD, password, sizeof(password)))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "PASSWORD");
        } 
        else
            api_add_list(REDSOCKS2_ETHERNET_PROXY_USE_PROFILE, "none", strlen("none"));


        if((http_obj = jsonTokenerParseFromStack(rep, http_obj_str)))
        {
            senao_json_object_get_boolean(http_obj, "enable", &enable);
            senao_json_object_get_and_create_string(rep, http_obj, "ip", &ip);
            senao_json_object_get_integer(http_obj, "port", &port);
            senao_json_object_get_boolean(http_obj, "is_auth_en", &is_auth_en);
            senao_json_object_get_and_create_string(rep, http_obj, "username", &username);
            senao_json_object_get_and_create_string(rep, http_obj, "password", &password);
        }
        if (enable == true)
        {
            api_add_list(REDSOCKS2_ETHERNET_PROXY_USE_PROFILE, "proxy2", strlen("proxy2"));
            if (api_set_redsocks_proxy_ip_http_url_option_by_sectionname(REDSOCKS2_PROXY2_IP, ip, sizeof(ip)))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "IP");

            if (api_set_redsocks_proxy_port_option_by_sectionname(REDSOCKS2_PROXY2_PORT, port))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "PORT");

            if (api_set_redsocks_proxy_authorization_option_by_sectionname(REDSOCKS2_PROXY2_AUTHORIZATION, is_auth_en))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "IS_AUTH_EN");

            if (api_set_redsocks_proxy_username_option_by_sectionname(REDSOCKS2_PROXY2_USERNAME, username, sizeof(username)))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "USERNAME");

            if (api_set_redsocks_proxy_password_option_by_sectionname(REDSOCKS2_PROXY2_PASSWORD, password, sizeof(password)))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "PASSWORD");
        }
        else
            api_add_list(REDSOCKS2_ETHERNET_PROXY_USE_PROFILE, "none", strlen("none"));

        memset(buf,0,sizeof(buf));
        sys_interact(buf, sizeof(buf), "echo %s | awk '{print NF}'", exclude_subnet);
        value_num = atoi(buf);

        for ( i = 0 ; i < value_num && i < 2 ; i++ )
        {
            memset(buf,0,sizeof(buf));
            sys_interact(buf, sizeof(buf), "echo %s | awk '{print $%d}'", exclude_subnet, i+1);
            if ( buf[strlen(buf)-1] == '\n' )
                buf[strlen(buf)-1] = 0;
            api_add_list(REDSOCKS2_ETHERNET_EXCLUDE_SUBNET, buf, strlen(buf));
        }
    }
}
int json_get_net_proxy_http(ResponseEntry *rep, struct json_object *jobj){

    char ip[128] = {0}, username[17] = {0}, password[17] = {0};
    int port, auth;
    ResponseStatus *res = rep->res;

    api_get_redsocks_proxy_ip_option_by_sectionname(REDSOCKS2_PROXY2_IP, ip, sizeof(ip));
    api_get_redsocks_proxy_port_option_by_sectionname(REDSOCKS2_PROXY2_PORT, &port);
    api_get_redsocks_proxy_authorization_option_by_sectionname(REDSOCKS2_PROXY2_AUTHORIZATION, &auth);
    api_get_redsocks_proxy_username_option_by_sectionname(REDSOCKS2_PROXY2_USERNAME, username, sizeof(ip));
    api_get_redsocks_proxy_password_option_by_sectionname(REDSOCKS2_PROXY2_PASSWORD, password, sizeof(ip));

    json_object_object_add(jobj, "ip", json_object_new_string(ip));
    json_object_object_add(jobj, "port", json_object_new_int(port));
    json_object_object_add(jobj, "is_auth_en", json_object_new_boolean(auth));
    json_object_object_add(jobj, "username", json_object_new_string(username));
    json_object_object_add(jobj, "password", json_object_new_string(password));

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}
int json_get_net_proxy_https(ResponseEntry *rep, struct json_object *jobj){

    char ip[128] = {0}, username[17] = {0}, password[17] = {0};
    int port, auth;
    ResponseStatus *res = rep->res;

    api_get_redsocks_proxy_ip_option_by_sectionname(REDSOCKS2_PROXY1_IP, ip, sizeof(ip));
    api_get_redsocks_proxy_port_option_by_sectionname(REDSOCKS2_PROXY1_PORT, &port);
    api_get_redsocks_proxy_authorization_option_by_sectionname(REDSOCKS2_PROXY1_AUTHORIZATION, &auth);
    api_get_redsocks_proxy_username_option_by_sectionname(REDSOCKS2_PROXY1_USERNAME, username, sizeof(ip));
    api_get_redsocks_proxy_password_option_by_sectionname(REDSOCKS2_PROXY1_PASSWORD, password, sizeof(ip));

    json_object_object_add(jobj, "ip", json_object_new_string(ip));
    json_object_object_add(jobj, "port", json_object_new_int(port));
    json_object_object_add(jobj, "is_auth_en", json_object_new_boolean(auth));
    json_object_object_add(jobj, "username", json_object_new_string(username));
    json_object_object_add(jobj, "password", json_object_new_string(password));

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}
int json_set_net_proxy_http(ResponseEntry *rep, char *query_str){

    char *ip=NULL, *username=NULL, *password=NULL;
    int port;
    bool is_auth_en = false;
    struct json_object *jobj;
    ResponseStatus *res = rep->res;

    if(NULL != query_str)
    {
        if((jobj = jsonTokenerParseFromStack(rep, query_str)))
        {
            senao_json_object_get_and_create_string(rep, jobj, "ip", &ip);
            senao_json_object_get_integer(jobj, "port", &port);
            senao_json_object_get_boolean(jobj, "is_auth_en", &is_auth_en);
            senao_json_object_get_and_create_string(rep, jobj, "username", &username);
            senao_json_object_get_and_create_string(rep, jobj, "password", &password);
        }
    }

    if (api_set_redsocks_proxy_ip_http_url_option_by_sectionname(REDSOCKS2_PROXY2_IP, ip, sizeof(ip)))
        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "IP");

    if (api_set_redsocks_proxy_port_option_by_sectionname(REDSOCKS2_PROXY2_PORT, port))
        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "PORT");

    if (api_set_redsocks_proxy_authorization_option_by_sectionname(REDSOCKS2_PROXY2_AUTHORIZATION, is_auth_en))
        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "IS_AUTH_EN");

    if (api_set_redsocks_proxy_username_option_by_sectionname(REDSOCKS2_PROXY2_USERNAME, username, sizeof(username)))
        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "USERNAME");

    if (api_set_redsocks_proxy_password_option_by_sectionname(REDSOCKS2_PROXY2_PASSWORD, password, sizeof(password)))
        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "PASSWORD");
}

int json_set_net_proxy_https(ResponseEntry *rep, char *query_str){

    char *ip=NULL, *username=NULL, *password=NULL;
    int port;
    bool is_auth_en = false;
    struct json_object *jobj;
    ResponseStatus *res = rep->res;

    if(NULL != query_str)
    {
        if((jobj = jsonTokenerParseFromStack(rep, query_str)))
        {
            senao_json_object_get_and_create_string(rep, jobj, "ip", &ip);
            senao_json_object_get_integer(jobj, "port", &port);
            senao_json_object_get_boolean(jobj, "is_auth_en", &is_auth_en);
            senao_json_object_get_and_create_string(rep, jobj, "username", &username);
            senao_json_object_get_and_create_string(rep, jobj, "password", &password);
        }
    }

    if (api_set_redsocks_proxy_ip_https_url_option_by_sectionname(REDSOCKS2_PROXY1_IP, ip, sizeof(ip)))
        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "IP");

    if (api_set_redsocks_proxy_port_option_by_sectionname(REDSOCKS2_PROXY1_PORT, port))
        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "PORT");

    if (api_set_redsocks_proxy_authorization_option_by_sectionname(REDSOCKS2_PROXY1_AUTHORIZATION, is_auth_en))
        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "IS_AUTH_EN");

    if (api_set_redsocks_proxy_username_option_by_sectionname(REDSOCKS2_PROXY1_USERNAME, username, sizeof(username)))
        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "USERNAME");

    if (api_set_redsocks_proxy_password_option_by_sectionname(REDSOCKS2_PROXY1_PASSWORD, password, sizeof(password)))
        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "PASSWORD");
}

int json_get_net_iptable_rules(ResponseEntry *rep, struct json_object *jobj){

    char use_profile[200] = {0};
    char exclude_subnet[200] = {0};
    ResponseStatus *res = rep->res;

    api_get_string_option(REDSOCKS2_ETHERNET_PROXY_USE_PROFILE, use_profile, sizeof (use_profile));
    api_get_string_option(REDSOCKS2_ETHERNET_EXCLUDE_SUBNET, exclude_subnet, sizeof (exclude_subnet));

    json_object_object_add(jobj, "use_profile", json_object_new_string(use_profile));
    json_object_object_add(jobj, "exclude_subnet", json_object_new_string(exclude_subnet));

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_set_net_iptable_rules(ResponseEntry *rep, char *query_str){

    char *use_profile=NULL;
    char *exclude_subnet=NULL;
    char buf[32] = {0};
    struct json_object *jobj;
    int value_num = 0, i = 0;

    if(NULL != query_str)
    {
        if((jobj = jsonTokenerParseFromStack(rep, query_str)))
        {
            senao_json_object_get_and_create_string(rep, jobj, "use_profile", &use_profile);
            senao_json_object_get_and_create_string(rep, jobj, "exclude_subnet", &exclude_subnet);
        }
    }

    api_delete_option(REDSOCKS2_ETHERNET_PROXY_USE_PROFILE, "");
    api_delete_option(REDSOCKS2_ETHERNET_EXCLUDE_SUBNET, "");

    memset(buf,0,sizeof(buf));
    sys_interact(buf, sizeof(buf), "echo %s | awk '{print NF}'", use_profile);
    value_num = atoi(buf);

    for ( i = 0 ; i < value_num && i < 2 ; i++ )
    {
        memset(buf,0,sizeof(buf));
        sys_interact(buf, sizeof(buf), "echo %s | awk '{print $%d}'", use_profile, i+1);
        if ( buf[strlen(buf)-1] == '\n' )
            buf[strlen(buf)-1] = 0;
        api_add_list(REDSOCKS2_ETHERNET_PROXY_USE_PROFILE, buf, strlen(buf));
    }

    memset(buf,0,sizeof(buf));
    sys_interact(buf, sizeof(buf), "echo %s | awk '{print NF}'", exclude_subnet);
    value_num = atoi(buf);

    for ( i = 0 ; i < value_num && i < 2 ; i++ )
    {
        memset(buf,0,sizeof(buf));
        sys_interact(buf, sizeof(buf), "echo %s | awk '{print $%d}'", exclude_subnet, i+1);
        if ( buf[strlen(buf)-1] == '\n' )
            buf[strlen(buf)-1] = 0;
        api_add_list(REDSOCKS2_ETHERNET_EXCLUDE_SUBNET, buf, strlen(buf));
    }
}

int json_get_net_spanning_tree(ResponseEntry *rep, struct json_object *jobj){

    int hello_time = 0, max_age = 0, forward_delay = 0, priority = 0;
    int enable = 0;
    ResponseStatus *res = rep->res;

#if SUPPORT_LIBCLOUDAP_SETTING
    api_get_lan_rstp_status_option(NETWORK_LAN_RSTP_STATUS_OPTION, &enable);
    api_get_lan_rstp_hello_time_option(NETWORK_LAN_RSTP_HELLO_TIME_OPTION, &hello_time);
    api_get_lan_rstp_max_age_option(NETWORK_LAN_RSTP_MAX_AGE_OPTION, &max_age);
    api_get_lan_rstp_forward_delay_option(NETWORK_LAN_RSTP_FORWARD_DELAY_OPTION, &forward_delay);
    api_get_lan_rstp_priority_option(NETWORK_LAN_RSTP_PRIORITY_OPTION, &priority);
#else
    api_get_lan_stp_status_option(NETWORK_LAN_STP_STATUS_OPTION, &enable);
    api_get_lan_stp_hello_time_option(NETWORK_LAN_HELLO_TIME_OPTION, &hello_time);
    api_get_lan_stp_max_age_option(NETWORK_LAN_MAX_AGE_OPTION, &max_age);
    api_get_lan_stp_forward_delay_option(NETWORK_LAN_FORWARD_DELAY_OPTION, &forward_delay);
    api_get_lan_stp_priority_option(NETWORK_LAN_PRIORITY_OPTION, &priority);
#endif

    json_object_object_add(jobj, "enable", json_object_new_boolean(enable));
    json_object_object_add(jobj, "hello_time", json_object_new_int(hello_time));
    json_object_object_add(jobj, "max_age", json_object_new_int(max_age));
    json_object_object_add(jobj, "forward_delay", json_object_new_int(forward_delay));
    json_object_object_add(jobj, "priority", json_object_new_int(priority));

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_set_net_spanning_tree(ResponseEntry *rep, char *query_str){

    int  hello_time = 0, max_age = 0, forward_delay = 0, priority = 0;
    bool enable = 0;
    struct json_object *jobj;
    ResponseStatus *res = rep->res;

    if(NULL != query_str)
    {
        if((jobj = jsonTokenerParseFromStack(rep, query_str)))
        {
            senao_json_object_get_boolean(jobj, "enable", &enable);
            senao_json_object_get_integer(jobj, "hello_time",&(hello_time));
            senao_json_object_get_integer(jobj, "max_age",&(max_age));
            senao_json_object_get_integer(jobj, "forward_delay",&(forward_delay));
            senao_json_object_get_integer(jobj, "priority",&(priority));
        }
    }

#if SUPPORT_LIBCLOUDAP_SETTING
    if (api_set_lan_rstp_status_option(NETWORK_LAN_RSTP_STATUS_OPTION, enable))
        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "ENABLE");
    if (enable == true)
    {
        if (api_set_lan_rstp_hello_time_option(NETWORK_LAN_RSTP_HELLO_TIME_OPTION, hello_time))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "HELLO TIME");
        if (api_set_lan_rstp_max_age_option(NETWORK_LAN_RSTP_MAX_AGE_OPTION, max_age))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "MAX AGE");
        if (api_set_lan_rstp_forward_delay_option(NETWORK_LAN_RSTP_FORWARD_DELAY_OPTION, forward_delay))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "FORWARD DELAY");
        if (api_set_lan_rstp_priority_option(NETWORK_LAN_RSTP_PRIORITY_OPTION, priority))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "PRIORITY");
    }
#else
    if (api_set_lan_stp_status_option(NETWORK_LAN_STP_STATUS_OPTION, enable))
        RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "ENABLE");
    if (enable == true)
    {
        if (api_set_lan_stp_hello_time_option(NETWORK_LAN_HELLO_TIME_OPTION, hello_time))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "HELLO TIME");
        if (api_set_lan_stp_max_age_option(NETWORK_LAN_MAX_AGE_OPTION, max_age))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "MAX AGE");
        if (api_set_lan_stp_forward_delay_option(NETWORK_LAN_FORWARD_DELAY_OPTION, forward_delay))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "FORWARD DELAY");
        if (api_set_lan_stp_priority_option(NETWORK_LAN_PRIORITY_OPTION, priority))
            RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "PRIORITY");
    }
#endif
}

int json_get_net_internet_speedtest(ResponseEntry *rep, struct json_object *jobj){

    char upload[16], download[16], upload_unit[10]={0}, download_unit[10]={0}, date[32]={0};
    char buf[32]={0};
    unsigned int process;
    ResponseStatus *res = rep->res;

    memset(buf, 0, sizeof(buf));
    memset(upload, 0, sizeof(upload));
    memset(download, 0, sizeof(download));

    sys_find_proc("speedtest-maste", &process);

    if(process>0)
    {
        RET_GEN_ERRORMSG(res, API_PROCESSING, "PROCESSING");
    }
    else if(sys_check_file_existed("/tmp/speedtest_result"))
    {
        sys_interact(buf, sizeof(buf), "cat /tmp/speedtest_result | grep \"date\" | wc -l");
		if(atoi(buf))
		{
            sys_interact(download, sizeof(download), "cat /tmp/speedtest_result | grep Download | awk '{print $2 \" \" $3}' | tr -d \"\n\"");
            sys_interact(upload, sizeof(upload), "cat /tmp/speedtest_result | grep Upload | awk '{print $2 \" \" $3}' | tr -d \"\n\"");
            sys_interact(date, sizeof(date), "cat /tmp/speedtest_result | grep date | awk '{print $2 \" \" $3}' | tr -d \"\n\"");

            json_object_object_add(jobj, "Upload", json_object_new_string(upload));
            json_object_object_add(jobj, "Download", json_object_new_string(download));
            json_object_object_add(jobj, "Timestamp", json_object_new_string(date));
        }
    }

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_set_net_internet_speedtest(ResponseEntry *rep, char *query_str){

    char buf[16]={0};
    unsigned int process;
    ResponseStatus *res = rep->res;

    sys_find_proc("speedtest-master", &process);

    if(process>0)
    {
        RET_GEN_ERRORMSG(res, API_PROCESSING, "PROCESSING");
    }
    else
    {
        memset(buf, 0x00, sizeof(buf));
        sys_interact(buf, sizeof(buf), "checkInternet.sh");

        if(strcmp(buf, "Online")!=0)
        {
            RET_GEN_ERRORMSG(res, API_INTERNET_ERROR, "NO INTERNET");
        }
        else
        {
            system("speedtest-master -f 1 -d 10 > /tmp/speedtest_result &");
        }
    }
}

int json_get_throughput_result(ResponseEntry *rep, char *query_str, struct json_object *jobj){

    char buf[64]={0}, buf2[4]={0}, source[32], upload[16], download[16], *ptr;
    ResponseStatus *res = rep->res;

    ptr = NULL;
    memset(source, 0, sizeof(source));
    memset(upload, 0, sizeof(upload));
    memset(download, 0, sizeof(download));

    if(FALSE == is_mesh_function_enabled())
    {
        RET_GEN_ERRORMSG(res, API_SUCCESS, "ERROR_MESH_DISABLED");
    }
    else
    {
        get_json_string_from_query(query_str, source, "Source");
        sys_interact(buf2, sizeof(buf2), "[ $(echo %s | grep -E \"^[a-fA-F0-9:]{17}$\") ] && echo -n 1 || echo -n 0", source);

        if(atoi(buf2))
        {
            sys_interact(buf, sizeof(buf), "/sbin/mesh.sh mac_to_ipv6_unique_local %s | tr -d '\\n'", source);
        }
        else
        {
            sprintf(buf, "%s", source);
        }

        if(check_mesh_global_ipv6(buf))
        {
            if(is_throughput_test_in_process())
            {
                RET_GEN_ERRORMSG(res, API_PROCESSING, "PROCESSING");
            }
            else if(sys_check_file_existed("/tmp/throughput_result"))
            {
                sys_interact(upload, sizeof(upload),"cat %s | grep SUM | awk \'/sender/{print $6, $7}\'", "/tmp/throughput_result");
                sys_interact(download, sizeof(download),"cat %s | grep SUM | awk \'/receiver/{print $6, $7}\'", "/tmp/throughput_result");

                if((strcmp("---", upload)) && strcmp("---", download))
                {
                    if(ptr = strchr(upload, '\n'))
                    {
                        *ptr = '\0';
                    }
                    if(ptr = strchr(download, '\n'))
                    {
                        *ptr = '\0';
                    }
                }
                json_object_object_add(jobj, "Upload", json_object_new_string(upload));
                json_object_object_add(jobj, "Download", json_object_new_string(download));
            }
        }
        else
        {
            redirect_to_target_mesh(rep, query_str, buf, jobj, ACTION_GET);
        }
        RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
    }
}
int json_set_throughput(ResponseEntry *rep, char *query_str){

    char source[32], buf[64]={0}, buf2[4]={0};
    struct json_object *jobj;
    ResponseStatus *res = rep->res;

    memset(source, 0x00, sizeof(source));

    if(FALSE == is_mesh_function_enabled())
    {
        RET_GEN_ERRORMSG(res, API_SUCCESS, "ERROR_MESH_DISABLED");
    }
    else
    {
        get_json_string_from_query(query_str, source, "target_mac_addr");

        sys_interact(buf2, sizeof(buf2), "[ $(echo %s | grep -E \"^[a-fA-F0-9:]{17}$\") ] && echo -n 1 || echo -n 0", source);
        if(atoi(buf2))
        {
            sys_interact(buf, sizeof(buf), "/sbin/mesh.sh mac_to_ipv6_unique_local %s | tr -d '\\n'", source);
        }
        else
        {
            sprintf(buf, "%s", source);
        }

        if(check_mesh_global_ipv6(buf))
        {
            run_throughput_test_cb(rep, query_str);
        }
        else
        {
            redirect_to_target_mesh(rep, query_str, buf, jobj, ACTION_POST);
        }
    }
}

int32_t create_wifix_channel_list(int wifix, int country_code, int green_mode)
{
    char channel_list[128] = {'\0'}, *pstr, cmd[128] = {'\0'}, cmd_get[128] = {'\0'}, buf[4096] = {'\0'}, channels_json_ary_str[4096] = {0}, token[127+1] = {'\0'}, filename[32+1] = {0}, *val;
    int wifidev = 0, old_country = 0, domain = 2, outdoor = 0, dfsCertified = 0, disable_band = 15, old_disable_band = 15, nochannel = 0, weather_ch = 0, old_weather_ch = 0;
    int result = 0;
    char *saveptr = NULL;

    FILE *pp;
    sprintf(cmd, "iwpriv wifi%d getCountryID", wifix);
    pp = popen(cmd, "r");
    if(pp == NULL )
    {
        printf("popen() error!\n");
        return false;
    }
    fgets(cmd_get, sizeof cmd_get, pp);
    pclose(pp);

    pstr = strtok_r(cmd_get, ":", &saveptr);
    pstr = strtok_r(NULL, ":", &saveptr);
    if (pstr == NULL)
            return false;

    old_country = atoi(pstr);

    if (sys_check_file_existed("/lib/wifi/RegularDomain.sh"))
    {
        memset(cmd, 0, sizeof(cmd));
#if SUPPORT_WIFI_10_2_VERSION
        sprintf(cmd, "iwpriv wifi%d get_disable_band", wifix);
#else
        sprintf(cmd, "iwpriv wifi%d g_disable_band", wifix);
#endif
        //printf("[%d]cmd: %s\n", __LINE__, cmd);
        pp = popen(cmd, "r");
        if(pp == NULL )
        {
            printf("popen() error!\n");
            return false;
        }
        memset(cmd_get, 0, sizeof(cmd_get));
        fgets(cmd_get, sizeof cmd_get, pp);
        pclose(pp);

        pstr = strtok_r(cmd_get, ":", &saveptr);
        pstr = strtok_r(NULL, ":", &saveptr);
        if (pstr == NULL)
        {
            return false;
        }

        old_disable_band = atoi(pstr);

        if (!sys_get_regular_domain_info(&domain))
        {
            domain = 2;
        }

        memset(buf, 0, sizeof (buf));
        if (sys_interact(buf, sizeof(buf), "iwpriv wifi%d g_weather_ch | awk -F\":\" '{print $2}'", wifix) > 0)
        {
            old_weather_ch = atoi(buf);
        }

        if (api_get_integer_option("sysProductInfo.model.outdoor", &outdoor))
            outdoor = 0;

        memset(token, 0, sizeof(token));
        switch (domain)
        {
            case 0:
                snprintf(token, sizeof(token), "sysProductInfo.model.fccDfsCertified");
                break;
            case 1:
                snprintf(token, sizeof(token), "sysProductInfo.model.etsiDfsCertified");
                break;
            default:
                if ((country_code == 32)||(country_code == 76)||(country_code == 124)||(country_code == 152)||
                    (country_code == 170)||(country_code == 188)||(country_code == 214)||(country_code == 218)||
                    (country_code == 320)||(country_code == 340)||(country_code == 458)||(country_code == 484)||
                    (country_code == 591)||(country_code == 604)||(country_code == 630)||(country_code == 840)||
                    (country_code == 858)||(country_code == 862))
                {
                    snprintf(token, sizeof(token), "sysProductInfo.model.fccDfsCertified");
                }
                else if ((country_code == 8)||(country_code == 40)||(country_code == 56)||(country_code == 100)||
                         (country_code == 191)||(country_code == 203)||(country_code == 208)||(country_code == 233)||
                         (country_code == 246)||(country_code == 250)||(country_code == 276)||(country_code == 300)||
                         (country_code == 348)||(country_code == 352)||(country_code == 372)||(country_code == 380)||
                         (country_code == 442)||(country_code == 492)||(country_code == 528)||(country_code == 578)||
                         (country_code == 616)||(country_code == 620)||(country_code == 642)||(country_code == 643)||
                         (country_code == 703)||(country_code == 705)||(country_code == 724)||(country_code == 752)||
                         (country_code == 756)||(country_code == 826)||(country_code == 829)||(country_code == 830))
                {
                    snprintf(token, sizeof(token), "sysProductInfo.model.etsiDfsCertified");
                }
        }
        if (!strcmp(token,"") || api_get_integer_option(token, &dfsCertified))
        {
            dfsCertified = 3;
        }
        memset(buf, 0, sizeof (buf));
#if SUPPORT_WLAN_5G_2_SETTING
        if (sys_interact(buf, sizeof(buf), "sh /lib/wifi/RegularDomain.sh %d %d %d %d %d %d 1", country_code, domain, green_mode, outdoor, dfsCertified) > 0)
#else
        if (sys_interact(buf, sizeof(buf), "sh /lib/wifi/RegularDomain.sh %d %d %d %d %d", country_code, domain, green_mode, outdoor, dfsCertified) > 0)
#endif
        {
            buf[strcspn(buf,"\n")] = '\0';
            val = strtok_r(buf," ", &saveptr);
            disable_band = atoi(val);
            val = strtok_r(NULL, " ", &saveptr);
            if(val != NULL){
                weather_ch = atoi(val);
                memset(cmd, 0, sizeof (cmd));
                sprintf(cmd, "iwpriv wifi%d weather_ch %d", wifix, weather_ch);
                //printf("[%d]cmd: %s\n", __LINE__, cmd);
                system(cmd);
            }
#if SUPPORT_WLAN_5G_2_SETTING
            if(wifix==1)
                disable_band=(disable_band & 12);
            else if(wifix==2)
                disable_band=(disable_band & 3);
            if (disable_band == 0)
                nochannel = 1;

            api_set_integer_option2(nochannel, "wireless.wifi%d.nochannel", wifix);
#endif
            if (!nochannel)
            {
                memset(cmd, 0, sizeof (cmd));
                sprintf(cmd, "iwpriv wifi%d disable_band %d", wifix, disable_band);
                system(cmd);
            }
        }
    }
    memset(cmd, 0, sizeof (cmd));
    sprintf(cmd, "iwpriv wifi%d setCountryID %d", wifix, country_code);
    system(cmd);

    memset(buf, 0, sizeof (buf));
    if (!nochannel)
        sys_interact(buf, sizeof(buf), "sh /sbin/getChannels.sh %d", wifix);

    memset(channels_json_ary_str, 0, sizeof(channels_json_ary_str));
    snprintf(channels_json_ary_str, sizeof(channels_json_ary_str), "[%s]", buf);

    memset(filename, 0, sizeof(filename));
    snprintf(filename, sizeof(filename), "%s%d", TMP_CHANNELS_FILE, wifix);
    FILE* fp = fopen(filename, "w");

    if( NULL == fp )
    {
        debug_print("%s open failure", filename);
    }
    else
    {
        result = fputs(channels_json_ary_str, fp);

        if ( result == EOF )
            debug_print("write %s fail", filename);

        fclose(fp);
    }

    if (sys_check_file_existed("/lib/wifi/RegularDomain.sh"))
    {
        memset(cmd, 0, sizeof (cmd));
        sprintf(cmd, "iwpriv wifi%d disable_band %d", wifix, old_disable_band);
        system(cmd);
        memset(cmd, 0, sizeof (cmd));
        sprintf(cmd, "iwpriv wifi%d weather_ch %d", wifix, old_weather_ch);
        system(cmd);
    }

    memset(cmd, 0, sizeof (cmd));
    sprintf(cmd, "iwpriv wifi%d setCountryID %d", wifix, old_country);
    system(cmd);

    return true;
}

int json_post_wifi_channel_list(ResponseEntry *rep, char *query_str, char *radio)
{
    ResponseStatus *res = rep->res;
    struct json_object *jobj, *jobj_greenmode;
    char *country = NULL;
    int i = 0, country_code = 0, regular = 0, max_ctry_num = 0, country_id = 0;
    bool green_mode = 0;
    country_code_t *countryTablePtr = NULL;

    if(NULL != query_str)
    {
        if((jobj = jsonTokenerParseFromStack(rep, query_str)))
        {
            senao_json_object_get_and_create_string(rep, jobj, "country", &country);
            country_id = atoi(country);

            /* country */
            if (sys_get_regular_domain_info(&regular))
            {
                // Get country code
                switch (regular)
                {
                    case REG_FCC:
                        countryTablePtr = FCC_CountryCodeTable;
                        max_ctry_num = sizeof(FCC_CountryCodeTable) / sizeof(country_code_t);
                        break;
                    case REG_ETSI:
                        countryTablePtr = ETSI_CountryCodeTable;
                        max_ctry_num = sizeof(ETSI_CountryCodeTable) / sizeof(country_code_t);
                        break;
                    default:
                        countryTablePtr = INT_CountryCodeTable;
                        max_ctry_num = sizeof(INT_CountryCodeTable) / sizeof(country_code_t);
                        break;
                }
            }

            for (i = 0; i < max_ctry_num; i++)
            {
                if (strcmp(countryTablePtr[i].name, country)==0 || countryTablePtr[i].code==country_id)
                {
                    country_code = countryTablePtr[i].code;
                }
            }

            if( country_code == 0 )
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "COUNTRY");

            senao_json_object_get_boolean(jobj, "green_mode", &green_mode);
#if SUPPORT_WLAN_24G_SETTING
            create_wifix_channel_list(0, country_code, green_mode?1:0);
#endif
#if SUPPORT_WLAN_5G_SETTING
            create_wifix_channel_list(1, country_code, green_mode?1:0);
#if SUPPORT_WLAN_5G_2_SETTING
            create_wifix_channel_list(2, country_code, green_mode?1:0);
#endif
#endif
        }
        else
        {
            RET_GEN_ERRORMSG(res, API_INVALID_DATA_TYPE, "JSON");
        }
    }
    else
    {
        RET_GEN_ERRORMSG(res, API_INVALID_DATA_TYPE, "JSON");
    }
    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}


int json_get_wifi_channel_list(ResponseEntry *rep, struct json_object *jobj)
{
    char buf[4096] = {0};
    int radio_idx = 0, arraylen = 0, json_array_idx = 0, channel = 0;
    char *ht20=NULL, *ht40=NULL, *ht80=NULL;
    struct json_object *jobj_channel, *jobj_ht20, *jobj_ht40, *jobj_ht20_40, *jobj_ht80, *jobj_channel_file, *jobj_radio;

    for(radio_idx = 0; radio_idx < T_NUM_OF_ELEMENTS(wifi_dev_name); ++radio_idx)
    {
        sys_interact(buf, sizeof(buf), "cat %s%d | tr -d '\n'", TMP_CHANNELS_FILE, wifi_dev_name[radio_idx][4]-'0');
        if ( jobj_channel_file = jsonTokenerParseFromStack(rep, buf) )
        {
            arraylen = json_object_array_length(jobj_channel_file);
            jobj_ht20 = newObjectArrayFromStack(rep);
            jobj_ht40 = newObjectArrayFromStack(rep);
            jobj_ht20_40 = newObjectArrayFromStack(rep);
            jobj_ht80 = newObjectArrayFromStack(rep);

            for ( json_array_idx = 0 ; json_array_idx < arraylen ; json_array_idx++ )
            {
                channel = 0;
                ht20 = ht40 = ht80 = NULL;
                jobj_channel = json_object_array_get_idx(jobj_channel_file,json_array_idx);

                senao_json_object_get_integer(jobj_channel,"Value",&channel);

                senao_json_object_get_and_create_string(rep,jobj_channel,"ht20",&ht20);
                senao_json_object_get_and_create_string(rep,jobj_channel,"ht40",&ht40);
                senao_json_object_get_and_create_string(rep,jobj_channel,"v80",&ht80);

                if ( (wifi_dev_name[radio_idx][4]-'0') == 0 )
                { // 2.4G
                    if ( ht20 && strlen(ht20) > 0 )
                        json_object_array_add(jobj_ht20,json_object_new_int(channel));
                    if ( ht40 && strlen(ht40) > 0 )
                        json_object_array_add(jobj_ht40,json_object_new_int(channel));
                    if ( ht20 && strlen(ht20) > 0 && ht40 && strlen(ht40) > 0 )
                        json_object_array_add(jobj_ht20_40,json_object_new_int(channel));
                }
                else
                { // 5G
                    json_object_array_add(jobj_ht20,json_object_new_int(channel)); // 5G always suport ht20
                    if ( ht40 && ( strlen(ht40) > 0 ) && ( ht40[0] == '1' ) )
                        json_object_array_add(jobj_ht40,json_object_new_int(channel));
                    if ( ht80 && ( strlen(ht80) > 0 ) && ( ht80[0] == '1' ) )
                        json_object_array_add(jobj_ht80,json_object_new_int(channel));
                }
            }

            jobj_radio = newObjectFromStack(rep);

            switch ( wifi_dev_name[radio_idx][4]-'0' )
            {
                case 0:
                    if ( json_object_array_length(jobj_ht20) > 0 )
                        json_object_object_add(jobj_radio,"ht_20", jobj_ht20);
                    if ( json_object_array_length(jobj_ht20_40) > 0 )
                        json_object_object_add(jobj_radio,"ht_20_40", jobj_ht20_40);
                    if ( json_object_array_length(jobj_ht40) > 0 )
                        json_object_object_add(jobj_radio,"ht_40", jobj_ht40);
                    json_object_object_add(jobj,"2_4G", jobj_radio);
                    break;
                case 1:
                    if ( json_object_array_length(jobj_ht20) > 0 )
                        json_object_object_add(jobj_radio,"ht_20", jobj_ht20);
                    if ( json_object_array_length(jobj_ht40) > 0 )
                        json_object_object_add(jobj_radio,"ht_40", jobj_ht40);
                    if ( json_object_array_length(jobj_ht80) > 0 )
                        json_object_object_add(jobj_radio,"ht_80", jobj_ht80);
                    json_object_object_add(jobj,"5G", jobj_radio);
                    break;
                case 2:
                    if ( json_object_array_length(jobj_ht20) > 0 )
                        json_object_object_add(jobj_radio,"ht_20", jobj_ht20);
                    if ( json_object_array_length(jobj_ht40) > 0 )
                        json_object_object_add(jobj_radio,"ht_40", jobj_ht40);
                    if ( json_object_array_length(jobj_ht80) > 0 )
                        json_object_object_add(jobj_radio,"ht_80", jobj_ht80);
                    json_object_object_add(jobj,"5G-2", jobj_radio);
                    break;
            }
        }
    }
}

int json_get_wifi_guest_network(ResponseEntry *rep, struct json_object *jobj)
{
    ResponseStatus *res = rep->res;
    char ip[32] = {0}, mask[32] = {0}, start_ip[32] = {0}, end_ip[32] = {0}, wins_server[32] = {0};

    api_get_wifi_guest_ipaddr_option(NETWORK_GUEST_IPADDR_OPTION, ip, sizeof(ip));
    api_get_wifi_guest_netmask_option(NETWORK_GUEST_NETMASK_OPTION, mask, sizeof(mask));
    api_get_wifi_guest_dhcp_start_option(DHCP_GUEST_START_OPTION, start_ip, sizeof start_ip);
    api_get_wifi_guest_dhcp_end_option(NULL, end_ip, sizeof end_ip);
    api_get_wifi_guest_wins_server_option(DHCP_GUEST_DHCP_OPTION_OPTION, wins_server, sizeof wins_server);

    json_object_object_add(jobj, "ip", json_object_new_string(ip));
    json_object_object_add(jobj, "mask", json_object_new_string(mask));
    json_object_object_add(jobj, "start", json_object_new_string(start_ip));
    json_object_object_add(jobj, "end", json_object_new_string(end_ip));
    json_object_object_add(jobj, "wins_server", json_object_new_string(wins_server));

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}
int json_set_wifi_guest_network(ResponseEntry *rep, char *query_str)
{
    char *ip = NULL, *mask = NULL, *start_ip = NULL, *end_ip = NULL, *wins_server = NULL;
    struct json_object *jobj;
    ResponseStatus *res = rep->res;

    if(NULL != query_str)
    {
        if((jobj = jsonTokenerParseFromStack(rep, query_str)))
        {
            senao_json_object_get_and_create_string(rep, jobj, "ip", &ip);
            senao_json_object_get_and_create_string(rep, jobj, "mask", &mask);
            senao_json_object_get_and_create_string(rep, jobj, "start", &start_ip);
            senao_json_object_get_and_create_string(rep, jobj, "end", &end_ip);
            senao_json_object_get_and_create_string(rep, jobj, "wins_server", &wins_server);

            if (api_set_wifi_guest_ipaddr_option(NETWORK_GUEST_IPADDR_OPTION, ip, sizeof(ip)))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "IP");

            if (api_set_wifi_guest_netmask_option(NETWORK_GUEST_NETMASK_OPTION, mask, sizeof(mask)))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "MASK");

            if (api_set_wifi_guest_dhcp_start_option(DHCP_GUEST_START_OPTION, start_ip, sizeof(start_ip)))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "START");

            if (api_set_wifi_guest_dhcp_end_option(NULL, end_ip, sizeof(end_ip)))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "END");

            if (api_set_wifi_guest_wins_server_option(DHCP_GUEST_DHCP_OPTION_OPTION, wins_server, sizeof(wins_server)))
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "WINS SERVER");

        }
    }


    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_get_sys_syslog(ResponseEntry *rep, struct json_object *jobj)
{
    int syslog_enable=0, trafficlog_enable=0, remotelog_enable=0, log_port=514;
    char log_ip[32]={0};

    ResponseStatus *res = rep->res;

    api_get_integer_option(SYSTEM_SYSTEM_SYSLOG_ENABLE_OPTION, &syslog_enable);
    api_get_integer_option(SYSTEM_SYSTEM_LOG_REMOTELOG_ENABLE_OPTION, &remotelog_enable);
    api_get_integer_option(SYSTEM_SYSTEM_LOG_TRAFFICLOG_ENABLE_OPTION, &trafficlog_enable);
    api_get_string_option(SYSTEM_SYSTEM_LOG_IP_OPTION,log_ip, sizeof(log_ip));
    api_get_integer_option(SYSTEM_SYSTEM_LOG_PORT_OPTION, &log_port);

    json_object_object_add(jobj, "syslog_enable", json_object_new_boolean(syslog_enable));
    json_object_object_add(jobj, "remotelog_enable", json_object_new_boolean(remotelog_enable));
    json_object_object_add(jobj, "trafficlog_enable", json_object_new_boolean(trafficlog_enable));
    json_object_object_add(jobj, "log_ip", json_object_new_string(log_ip));
    json_object_object_add(jobj, "log_port", json_object_new_int(log_port));

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_set_sys_syslog(ResponseEntry *rep, char *query_str)
{
    char *log_ip = NULL;
    bool syslog_enable=true,trafficlog_enable=true, remotelog_enable=true;
    int log_port=0;
    struct json_object *jobj;

    ResponseStatus *res = rep->res;

    if(NULL != query_str)
    {
	if((jobj = jsonTokenerParseFromStack(rep, query_str)))
	{
	    senao_json_object_get_boolean(jobj, "syslog_enable",&syslog_enable);
	    senao_json_object_get_boolean(jobj, "remotelog_enable",&remotelog_enable);
	    senao_json_object_get_boolean(jobj, "trafficlog_enable",&trafficlog_enable);
            senao_json_object_get_and_create_string(rep, jobj, "log_ip", &log_ip);
	    senao_json_object_get_integer(jobj, "log_port",&(log_port));

            if (api_set_integer_option(SYSTEM_SYSTEM_SYSLOG_ENABLE_OPTION,(syslog_enable?1:0)) != API_RC_SUCCESS)
                RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "syslog_enable");

	    if (api_set_integer_option(SYSTEM_SYSTEM_LOG_REMOTELOG_ENABLE_OPTION,(remotelog_enable?1:0)) != API_RC_SUCCESS)
		RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "remotelog_enable");

	    if(remotelog_enable == true)
	    {
		if (api_set_integer_option(SYSTEM_SYSTEM_LOG_TRAFFICLOG_ENABLE_OPTION,(trafficlog_enable?1:0)) != API_RC_SUCCESS)
			RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "trafficlog_enable");

		if (api_set_system_log_ip_option(SYSTEM_SYSTEM_LOG_IP_OPTION, log_ip, sizeof(log_ip)) != API_RC_SUCCESS)
			RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "log_ip");

		if (api_set_system_log_port_option(SYSTEM_SYSTEM_LOG_PORT_OPTION, log_port) != API_RC_SUCCESS)
			RET_GEN_ERRORMSG(res, API_INVALID_ARGUMENTS, "log_port");
	    }
	}
    }
    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int is_scanning_radio()
{
    return access(SCAN_RADIO_FILE_DIR, F_OK);
}

char *ltrim(char *str)
{
    int len = 0;
    char *p = str;

    if (str == NULL || *str == '\0')
        return str;

    while (*p != '\0' && isspace(*p))
    {
        ++p;
        ++len;
    }
    memmove(str, p, strlen(str) - len +1);

    return str;
}

int read_channel_util_info(struct json_object *jobj, char *path)
{
    struct json_object* jobj_tmp;
    int channel = 0, utilization = 0;

    FILE *fd = NULL;
    char line[1024]={0};

    //debug_print("==========read_channel_util_info==========\n");

    fd = fopen(path, "r");

    if (fd == NULL)
    {
        return false;
    }

    while(fgets(line, sizeof(line), fd)!=NULL)
    {
        /*
        channel:165 utilization:3
        channel:01 utilization:139
        channel:02 utilization:72
        */

        line[strcspn(line,"\n")] = '\0';
        if (strlen(line) == 0 || !strcmp(line,""))
            continue;

        if (sscanf(line, "channel:%d utilization:%d", &channel, &utilization) > 1)
        {
            jobj_tmp = json_object_new_object();
            json_object_object_add(jobj_tmp, "chan", json_object_new_int(channel));
            json_object_object_add(jobj_tmp, "value", json_object_new_int(utilization));
            json_object_array_add(jobj, jobj_tmp);
        }

    }
    fclose(fd);

    return true;
}

int json_get_wifi_scan_chanutil(ResponseEntry *rep, struct json_object *jobj)
{
    FILE *pFile = NULL;
    char buf[128]={0};
    char path[64]={0};
    char *pch = NULL, *rch = NULL;
    ResponseStatus *res = rep->res;
    struct json_object* jarr;
    struct json_object *json_node = NULL;

    if (access(TMP_WIFI_SCAN_FILE_DIR,F_OK) < 0)
    {
        if (is_scanning_radio() < 0)
        {
            if (access(BACKGROUND_SCAN_FILE_DIR,F_OK) < 0)
            {
                sys_interact(buf, sizeof(buf), "mkdir %s", BACKGROUND_SCAN_FILE_DIR);
            }
            memset(buf, 0, sizeof(buf));
            sys_interact(buf, sizeof(buf), "ln -sf %s %s", BACKGROUND_SCAN_FILE, WIFI_SCAN_FILE);
        }
        else
        {
            if (access(SCAN_RADIO_FILE_DIR,F_OK) == 0)
            {
                memset(buf, 0, sizeof(buf));
                sys_interact(buf, sizeof(buf), "ln -sf %s %s", SCAN_RADIO_FILE, WIFI_SCAN_FILE);
            }
        }
    }

    jarr = newObjectArrayFromStack(rep);

    memset(buf, 0, sizeof(buf));

    sys_interact(buf, sizeof(buf), "ls %s | grep %s | xargs", TMP_WIFI_SCAN_FILE_DIR, CHANUTIL_FILENAME);
    buf[strcspn(buf,"\n")] = '\0';
    if (strcmp(buf, "") == 0)
    {
        debug_print("---No channel utilization Data---\n");
        RET_GEN_ERRORMSG(res, API_FILE_NOT_EXIST, NULL);
    }

    pch = strtok_r(buf, " ", &rch);
    while (pch != NULL)
    {
        memset(path, 0, sizeof(path));
        snprintf(path, sizeof(path), "%s%s", TMP_WIFI_SCAN_FILE_DIR, pch);
        read_channel_util_info(jarr, path);
        pch = strtok_r(rch, " ", &rch);
    }
    json_object_object_add(jobj, "chanutil", jarr);
    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);

}

int create_ap_list_json(char *source, json_object *jobj_tmp)
{
    int c = 0;
    char *pstr = NULL;
    char buf[32]={0};
    char bssid[128]={0}, privacy_type[64]={0}, cipher_type[64]={0}, auth_type[64]={0}, ssid[128]={0}, chwidth[64]={0}, mode[64]={0};
    int channel=0, power=0;

    //debug_print("==========create_ap_list_json==========\n");

    /*
    char *saveptr = NULL;
    pstr = strtok_r(source,",",&saveptr);
    while (pstr != NULL)
    {
        switch (c)
        {
            case 0:
                json_object_object_add(root, "bssid", json_object_new_string(ltrim(pstr)));
                break;
            case 3:
                json_object_object_add(root, "chan", json_object_new_string(ltrim(pstr)));
                break;
            case 5:
                json_object_object_add(root, "privacy_type", json_object_new_string(ltrim(pstr)));
                break;
            case 6:
                json_object_object_add(root, "cipher_type", json_object_new_string(ltrim(pstr)));
                break;
            case 7:
                json_object_object_add(root, "auth_type", json_object_new_string(ltrim(pstr)));
                break;
            case 8:
                json_object_object_add(root, "power", json_object_new_string(ltrim(pstr)));
                break;
            case 14:
                json_object_object_add(root, "chwidth", json_object_new_string(ltrim(pstr)));
                break;
            case 15:
                json_object_object_add(root, "mode", json_object_new_string(ltrim(pstr)));
                break;
            case 16:
                pstr[strcspn(pstr, "^M")] = '\0';
                json_object_object_add(root, "ssid", json_object_new_string(ltrim(pstr)));
                break;
            default:
                break;
        }
        pstr = strtok_r(NULL, ",", &saveptr);
        c++;
    }
    */

    if (sscanf(source, "%[^,],%*[^,],%*[^,],%d,%*d,%[^,],%[^,],%[^,],%d,%*d,%*d,%*[^,],%*d,%*[^,],%[^,],%[^,],%s", bssid, &channel, privacy_type, cipher_type
                    , auth_type, &power, chwidth, mode, ssid) > 0)
    {
        json_object_object_add(jobj_tmp, "bssid", json_object_new_string(ltrim(bssid)));
        json_object_object_add(jobj_tmp, "chan", json_object_new_int(channel));
        json_object_object_add(jobj_tmp, "privacy_type", json_object_new_string(ltrim(privacy_type)));
        json_object_object_add(jobj_tmp, "cipher_type", json_object_new_string(ltrim(cipher_type)));
        json_object_object_add(jobj_tmp, "auth_type", json_object_new_string(ltrim(auth_type)));
        json_object_object_add(jobj_tmp, "power", json_object_new_int(power));
        json_object_object_add(jobj_tmp, "chwidth", json_object_new_string(ltrim(chwidth)));
        json_object_object_add(jobj_tmp, "mode", json_object_new_string(ltrim(mode)));
        json_object_object_add(jobj_tmp, "ssid", json_object_new_string(ssid));
    }


    return true;
}

int read_ap_list_info(struct json_object *jobj, char *path)
{
    struct json_object* jobj_tmp;

    FILE *fd = NULL;
    char line[1024]={0};

    //debug_print("==========read_ap_list_info==========\n");

    fd = fopen(path, "r");

    if (fd == NULL)
    {
        return false;
    }

    while(fgets(line, sizeof(line), fd)!=NULL)
    {
        //88:DC:96:02:01:81, 2020-03-27 02:09:28, 2020-03-27 02:13:43, 36, 780, OPN, ,   , -84,      403,        0,   0.  0.  0.  0,  11, , HT80, AC, AP SSID_5G7^M
        //debug_print("=====line:%s====\n", line);

        line[strcspn(line, "\n")] = '\0';
        line[strcspn(line, "\r")] = '\0';
        if (strlen(line) == 0 || !strcmp(line,""))
            continue;

        if(strcmp(line, "^M") == 0)
            continue;

        jobj_tmp = json_object_new_object();

        //if (sscanf(line, "%[^,], %[^,], %[^,],%d,%d,%[^,],%[^,],%[^,],%d,%d,%d,%[^,],%d,%[^,],%[^,], %[^,], %[^^]", bssid, first_seen, last_seen, &channel, &speed, privacy_type, cipher_type
        //            , auth_type, &power, &beacon, &iv, lan_ip, &id_len, key, chwidth, mode, ssid) > 0)
        if (create_ap_list_json(line, jobj_tmp))
            json_object_array_add(jobj, jobj_tmp);

    }
    fclose(fd);

    return true;
}

int json_get_wifi_scan_aplist(ResponseEntry *rep, struct json_object *jobj)
{
    char buf[128]={0};
    char path[64]={0};
    char *pch = NULL, *rch = NULL;

    ResponseStatus *res = rep->res;
    struct json_object* jarr;

    debug_print("===========json_get_wifi_scan_aplist===========\n");
    memset(buf, 0, sizeof(buf));

    if (access(TMP_WIFI_SCAN_FILE_DIR,F_OK) < 0)
    {
        if (is_scanning_radio() < 0)
        {
            if (access(BACKGROUND_SCAN_FILE_DIR,F_OK) < 0)
            {
                sys_interact(buf, sizeof(buf), "mkdir %s", BACKGROUND_SCAN_FILE_DIR);
            }
            memset(buf, 0, sizeof(buf));
            sys_interact(buf, sizeof(buf), "ln -sf %s %s", BACKGROUND_SCAN_FILE, WIFI_SCAN_FILE);
        }
        else
        {
            if (access(SCAN_RADIO_FILE_DIR,F_OK) == 0)
            {
                memset(buf, 0, sizeof(buf));
                sys_interact(buf, sizeof(buf), "ln -sf %s %s", SCAN_RADIO_FILE, WIFI_SCAN_FILE);
            }
        }
    }

    jarr = newObjectArrayFromStack(rep);

    memset(buf, 0, sizeof(buf));

    sys_interact(buf, sizeof(buf), "ls %s | grep %s | xargs", TMP_WIFI_SCAN_FILE_DIR, AP_LIST_FILENAME);
    buf[strcspn(buf,"\n")] = '\0';
    if (strcmp(buf, "") == 0)
    {
        json_object_object_add(jobj, "ap_list", jarr);
        debug_print("---No AP List Data---\n");
        RET_GEN_ERRORMSG(res, API_FILE_NOT_EXIST, NULL);
    }

    pch = strtok_r(buf, " ", &rch);
    while (pch != NULL)
    {
        memset(path, 0, sizeof(path));
        snprintf(path, sizeof(path), "%s%s", TMP_WIFI_SCAN_FILE_DIR, pch);
        read_ap_list_info(jarr, path);
        pch = strtok_r(rch, " ", &rch);
    }
    json_object_object_add(jobj, "ap_list", jarr);
    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int create_sta_list_json(char *source, json_object *root)
{
    int c = 0;
    char *pstr = NULL;
    char buf[32]={0};
    char *saveptr = NULL;

    pstr = strtok_r(source, ",", &saveptr);
    while (pstr != NULL)
    {
        switch (c)
        {
            case 0:
                //debug_print("=====ltrim(pstr):%s====\n", ltrim(pstr));
                json_object_object_add(root, "sta_mac", json_object_new_string(ltrim(pstr)));
                break;
            case 3:
                json_object_object_add(root, "power", json_object_new_string(ltrim(pstr)));
                break;
            case 6:
                json_object_object_add(root, "ass_bssid", json_object_new_string(ltrim(pstr)));
                break;
            //case 7:
            //    json_object_object_add(root, "probed_ssid", json_object_new_string(ltrim(pstr)));
            default:
                break;
        }
        pstr = strtok_r(NULL, ",", &saveptr);
        c++;
    }

    return true;
}

int read_sta_list_info(struct json_object *jobj, char *path)
{
    struct json_object* jobj_tmp;

    FILE *fd = NULL;
    char line[1024]={0};

    //debug_print("==========read_sta_list_info==========\n");

    fd = fopen(path, "r");

    if (fd == NULL)
    {
        return false;
    }

    while(fgets(line, sizeof(line), fd)!=NULL)
    {
        /*
        0A:C7:72:B5:18:E2, 2020-03-27 02:10:39, 2020-03-27 02:10:39,  -82,  0,        4,(not associated) ,q2.4_WPA3_E^M
        CA:38:99:F7:30:2C, 2020-03-27 02:10:12, 2020-03-27 02:10:12,  -72,  0,        2,(not associated) ,^M
        6C:C7:EC:DD:01:F5, 2020-03-27 02:10:01, 2020-03-27 02:10:01,  -83,  0,        1,(not associated) ,SNGUEST^M
        50:BC:96:B3:3F:07, 2020-03-27 02:09:29, 2020-03-27 02:12:41,  -84, 36,       41,88:DC:96:42:9C:67,^M
        */


        line[strcspn(line, "\n")] = '\0';
        line[strcspn(line, "\r")] = '\0';
        if (strlen(line) == 0 || !strcmp(line,""))
            continue;

        if(strcmp(line, "^M") == 0)
            continue;

        jobj_tmp = json_object_new_object();

        if (create_sta_list_json(line, jobj_tmp))
            json_object_array_add(jobj, jobj_tmp);

    }
    fclose(fd);

    return true;
}


int json_get_wifi_scan_stalist(ResponseEntry *rep, struct json_object *jobj)
{
    ResponseStatus *res = rep->res;
    struct json_object* jarr;

    char buf[128]={0};
    char path[64]={0};
    char *pch = NULL, *rch = NULL;

    //debug_print("==========json_get_wifi_scan_24g_stalist==========\n");

    memset(buf, 0, sizeof(buf));

    if (access(TMP_WIFI_SCAN_FILE_DIR,F_OK) < 0)
    {
        if (is_scanning_radio() < 0)
        {
            if (access(BACKGROUND_SCAN_FILE_DIR,F_OK) < 0)
            {
                sys_interact(buf, sizeof(buf), "mkdir %s", BACKGROUND_SCAN_FILE_DIR);
            }
            memset(buf, 0, sizeof(buf));
            sys_interact(buf, sizeof(buf), "ln -sf %s %s", BACKGROUND_SCAN_FILE, WIFI_SCAN_FILE);
        }
        else
        {
            if (access(SCAN_RADIO_FILE_DIR,F_OK) == 0)
            {
                memset(buf, 0, sizeof(buf));
                sys_interact(buf, sizeof(buf), "ln -sf %s %s", SCAN_RADIO_FILE, WIFI_SCAN_FILE);
            }
        }
    }

   jarr = newObjectArrayFromStack(rep);

    memset(buf, 0, sizeof(buf));

    sys_interact(buf, sizeof(buf), "ls %s | grep %s | xargs", TMP_WIFI_SCAN_FILE_DIR, STA_LIST_FILENAME);
    buf[strcspn(buf,"\n")] = '\0';
    if (strcmp(buf, "") == 0)
    {
        json_object_object_add(jobj, "sta_list", jarr);
        debug_print("---No STA List Data---\n");
        RET_GEN_ERRORMSG(res, API_FILE_NOT_EXIST, NULL);
    }

    pch = strtok_r(buf, " ", &rch);
    while (pch != NULL)
    {
        memset(path, 0, sizeof(path));
        snprintf(path, sizeof(path), "%s%s", TMP_WIFI_SCAN_FILE_DIR, pch);
        read_sta_list_info(jarr, path);
        pch = strtok_r(rch, " ", &rch);
    }
    json_object_object_add(jobj, "sta_list", jarr);

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_get_wifi_vpn_profile(ResponseEntry *rep, struct json_object *jobj)
{
    ResponseStatus *res = rep->res;

    struct json_object *jarr, *jobj_tmp;
    struct json_object *jobj_vpn_remote = NULL, *tunnel_obj = NULL, *p2proposal_obj = NULL;
    struct json_object *p1_jarr = NULL, *p1_jobj_info = NULL, *route_jarr = NULL, *route_obj = NULL;

    char buf[256] = {0}, p1_buf[256] = {0}, tunnel_buf[256] = {0}, route_buf[256] = {0}, p2_buf[256] = {0};
    char *profile = NULL, *_profile = NULL, *p1proposal = NULL, *_p1proposal = NULL, *route_str = NULL, *route = NULL;

    PROFILE_SETTING profile_data;
    P1_PROPOSAL_SETTING p1_data;
    TUNNEL_SETTING tunnel_data;
    ROUTE_SETTING route_data;
    P2_PROPOSAL_SETTING p2_data;

    jarr = newObjectArrayFromStack(rep);

    memset(buf, 0, sizeof(buf));
    sys_interact(buf, sizeof(buf), "foreach ipsec_profile profile");
    profile=strtok_r(buf, "\n", &_profile);
    while(profile != NULL)
    {
        api_get_vpn_profile_section(&profile_data, profile);
        jobj_tmp = newObjectFromStack(rep);
        jobj_vpn_remote = newObjectFromStack(rep);
        json_object_object_add(jobj_tmp, "vpn_profile_name", json_object_new_string(profile_data.profile_name));
        json_object_object_add(jobj_vpn_remote, "enable", json_object_new_boolean(profile_data.enable));
        json_object_object_add(jobj_vpn_remote, "type", json_object_new_string(profile_data.vpn_type));
        json_object_object_add(jobj_vpn_remote, "gateway", json_object_new_string(profile_data.gateway));
        json_object_object_add(jobj_vpn_remote, "authentication_method", json_object_new_string(profile_data.authentication_method));
        json_object_object_add(jobj_vpn_remote, "pre_shared_key", json_object_new_string(profile_data.pre_shared_key));
        json_object_object_add(jobj_vpn_remote, "identity", json_object_new_string(profile_data.identity));
        json_object_object_add(jobj_vpn_remote, "password", json_object_new_string(profile_data.password));

        //=================p1 proposal===================//
        p1_jarr = newObjectArrayFromStack(rep);

        memset(p1_buf, 0, sizeof(p1_buf));
        sys_interact(p1_buf, sizeof(p1_buf), "foreach ipsec_profile p1_proposal attached %s", profile_data.profile_name);

        p1proposal = strtok_r(p1_buf, "\n", &_p1proposal);
        while(p1proposal != NULL)
        {

            api_get_vpn_p1_proposal_section(&p1_data, p1proposal);
            p1_jobj_info = newObjectFromStack(rep);
            json_object_object_add(p1_jobj_info, "encryption_algorithm", json_object_new_string(p1_data.encryption_algorithm));
            json_object_object_add(p1_jobj_info, "hash_algorithm", json_object_new_string(p1_data.hash_algorithm));
            json_object_object_add(p1_jobj_info, "dh_group", json_object_new_string(p1_data.dh_group));

            json_object_array_add(p1_jarr, p1_jobj_info);

            p1proposal =strtok_r(NULL, "\n", &_p1proposal);
        }
        json_object_object_add(jobj_vpn_remote, "p1_proposal", p1_jarr);

        //=================p1 proposal end===================//
        json_object_object_add(jobj_tmp, "vpn_remote", jobj_vpn_remote);


        //=================tunnel===================//
        tunnel_obj = newObjectFromStack(rep);

        memset(tunnel_buf, 0, sizeof(tunnel_buf));
        sys_interact(tunnel_buf, sizeof(tunnel_buf), "foreach ipsec_profile tunnel attached %s", profile_data.profile_name);
        if ( tunnel_buf[strlen(tunnel_buf)-1] == '\n' )
            tunnel_buf[strlen(tunnel_buf)-1] = 0;

        api_get_vpn_tunnel_section(&tunnel_data, tunnel_buf);
        json_object_object_add(tunnel_obj, "local_subnet", json_object_new_string(tunnel_data.local_subnet));
        json_object_object_add(tunnel_obj, "remote_subnet", json_object_new_string(tunnel_data.remote_subnet));
        json_object_object_add(tunnel_obj, "force_traffic", json_object_new_boolean(profile_data.force_traffic));
        //=================tunnel end===================//

        //=================route===================//
        memset(route_buf, 0, sizeof(route_buf));
        sys_interact(route_buf, sizeof(route_buf), "foreach ipsec_profile route attached %s", profile_data.profile_name);
        if ( route_buf[strlen(route_buf)-1] == '\n' )
            route_buf[strlen(route_buf)-1] = 0;

        route_jarr = newObjectArrayFromStack(rep);

        memset(route_data.route, 0, sizeof(route_data.route));
        api_get_vpn_route_section(&route_data, route_buf);

        route = strtok_r(route_data.route, " ", &route_str);
        while(route != NULL)
        {
            route_obj = newObjectFromStack(rep);
            json_object_object_add(route_obj, "route", json_object_new_string(route));
            json_object_array_add(route_jarr, route_obj);
            route =strtok_r(NULL, " ", &route_str);
        }

        json_object_object_add(tunnel_obj, "route", route_jarr);

        //=================route end===================//

        //=====================p2 proposal========================//
        memset(p2_buf, 0, sizeof(p2_buf));
        sys_interact(p2_buf, sizeof(p2_buf), "foreach ipsec_profile p2_proposal attached %s", profile_data.profile_name);
        if ( p2_buf[strlen(p2_buf)-1] == '\n' )
            p2_buf[strlen(p2_buf)-1] = 0;

        api_get_vpn_p2_proposal_section(&p2_data, p2_buf);

        p2proposal_obj = newObjectFromStack(rep);
        json_object_object_add(p2proposal_obj, "encryption_algorithm", json_object_new_string(p2_data.encryption_algorithm));
        json_object_object_add(p2proposal_obj, "hash_algorithm", json_object_new_string(p2_data.hash_algorithm));
        json_object_object_add(tunnel_obj, "p2_proposal", p2proposal_obj);
        //=====================p2 proposal end========================//


        json_object_object_add(jobj_tmp, "vpn_tunnel", tunnel_obj);


        json_object_array_add(jarr, jobj_tmp);
        profile =strtok_r(NULL, "\n", &_profile);
    }
    json_object_object_add(jobj, "profile", jarr);


    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_set_wifi_vpn_profile(ResponseEntry *rep, char *query_str)
{
    ResponseStatus *res = rep->res;

    struct json_object *jobj = NULL, *remote_obj = NULL, *tunnel_obj = NULL, *p2proposal_obj = NULL, *profile_obj = NULL;
    struct json_object *p1_jarr = NULL, *p1_jarr_info = NULL, *route_jarr = NULL, *route_jarr_info = NULL;

    char *profileName = NULL, *remote_obj_str = NULL, *tunnel_obj_str = NULL, *type = NULL, *gateway = NULL, *auth_method = NULL;
    char *preShareKey = NULL, *eapIdentity = NULL, *eapPassword = NULL, *p1proposal_str = NULL, *encryption_alg = NULL;
    char *hash_alg = NULL, *dhGroup = NULL, *localSubnet = NULL, *remoteSubnet = NULL, *route_str = NULL, *route = NULL;
    char *p2proposal_str = NULL, *p2_encr_algo = NULL, *p2_auth_algo = NULL;
    char buf[256] = {0};
    bool enable = 0, forceTraffic = 0;
    int arraylen = 0, json_array_idx = 0, j = 0, profile_len = 0, profile_num = 0;

    PROFILE_SETTING profile_data;
    P1_PROPOSAL_SETTING p1_data;
    TUNNEL_SETTING tunnel_data;
    ROUTE_SETTING route_data;
    P2_PROPOSAL_SETTING p2_data;

    if(NULL != query_str)
    {
        if((jobj = jsonTokenerParseFromStack(rep, query_str)))
        {
            profile_len = json_object_array_length(jobj);

            for ( profile_num = 0; profile_num < profile_len; profile_num++ )
            {
                profile_obj = json_object_array_get_idx(jobj, profile_num);
                senao_json_object_get_and_create_string(rep, profile_obj, "vpn_profile_name", &profileName);
                senao_json_object_get_and_create_string(rep, profile_obj, "vpn_remote", &remote_obj_str);
                senao_json_object_get_and_create_string(rep, profile_obj, "vpn_tunnel", &tunnel_obj_str);

                strcpy(profile_data.profile_name, profileName);

                if((remote_obj = jsonTokenerParseFromStack(rep, remote_obj_str)))
                {
                    senao_json_object_get_boolean(remote_obj, "enable", &enable);
                    senao_json_object_get_and_create_string(rep, remote_obj, "type", &type);
                    senao_json_object_get_and_create_string(rep, remote_obj, "gateway", &gateway);
                    senao_json_object_get_and_create_string(rep, remote_obj, "authentication_method", &auth_method);
                    senao_json_object_get_and_create_string(rep, remote_obj, "pre_shared_key", &preShareKey);
                    senao_json_object_get_and_create_string(rep, remote_obj, "identity", &eapIdentity);
                    senao_json_object_get_and_create_string(rep, remote_obj, "password", &eapPassword);
                    senao_json_object_get_and_create_string(rep, remote_obj, "p1_proposal", &p1proposal_str);

                    profile_data.enable=enable;
                    strcpy(profile_data.vpn_type, type);
                    strcpy(profile_data.gateway, gateway);
                    strcpy(profile_data.authentication_method, auth_method);
                    strcpy(profile_data.pre_shared_key, preShareKey);
                    strcpy(profile_data.identity, eapIdentity);
                    strcpy(profile_data.password, eapPassword);
                }

                //=================tunnel===================//
                if((tunnel_obj = jsonTokenerParseFromStack(rep, tunnel_obj_str)))
                {
                    senao_json_object_get_and_create_string(rep, tunnel_obj, "local_subnet", &localSubnet);
                    senao_json_object_get_and_create_string(rep, tunnel_obj, "remote_subnet", &remoteSubnet);
                    senao_json_object_get_boolean(tunnel_obj, "force_traffic", &forceTraffic);
                    senao_json_object_get_and_create_string(rep, tunnel_obj, "route", &route_str);

                    profile_data.force_traffic=forceTraffic;
                    strcpy(tunnel_data.profile_name, profileName);
                    strcpy(tunnel_data.local_subnet, localSubnet);
                    strcpy(tunnel_data.remote_subnet, remoteSubnet);

                    //=================p2 proposal===================//
                    senao_json_object_get_and_create_string(rep, tunnel_obj, "p2_proposal", &p2proposal_str);

                    if((p2proposal_obj = jsonTokenerParseFromStack(rep, p2proposal_str)))
                    {
                        senao_json_object_get_and_create_string(rep, p2proposal_obj, "encryption_algorithm", &p2_encr_algo);
                        senao_json_object_get_and_create_string(rep, p2proposal_obj, "hash_algorithm", &p2_auth_algo);

                        strcpy(p2_data.profile_name, profileName);
                        strcpy(p2_data.encryption_algorithm, p2_encr_algo);
                        strcpy(p2_data.hash_algorithm, p2_auth_algo);
                    }
                    //=================p2 proposal end===================//
                }
                //=================tunnel end===================//
        
                api_set_vpn_profile_section(profile_data);

                //=================p1 proposal===================//
                if(p1_jarr = jsonTokenerParseFromStack(rep, p1proposal_str))
                {
                    arraylen = json_object_array_length(p1_jarr);

                    for (json_array_idx = 0; json_array_idx < arraylen; json_array_idx++)
                    {
                        p1_jarr_info = json_object_array_get_idx(p1_jarr, json_array_idx);

                        senao_json_object_get_and_create_string(rep, p1_jarr_info, "encryption_algorithm", &encryption_alg);
                        senao_json_object_get_and_create_string(rep, p1_jarr_info, "hash_algorithm", &hash_alg);
                        senao_json_object_get_and_create_string(rep, p1_jarr_info, "dh_group", &dhGroup);

                        strcpy(p1_data.profile_name, profileName);
                        strcpy(p1_data.encryption_algorithm, encryption_alg);
                        strcpy(p1_data.hash_algorithm, hash_alg);
                        strcpy(p1_data.dh_group, dhGroup);

                        api_set_vpn_p1_proposal_section(p1_data);
                    }
                }
                //=================p1 proposal end===================//

                api_set_vpn_tunnel_section(tunnel_data);
                api_set_vpn_p2_proposal_section(p2_data);

                //=================route===================//
                if(route_jarr = jsonTokenerParseFromStack(rep, route_str))
                {
                    memset(buf, 0, sizeof(buf));
                    j=0;
                    arraylen = json_object_array_length(route_jarr);

                    for (json_array_idx = 0; json_array_idx < arraylen; json_array_idx++)
                    {
                        route_jarr_info = json_object_array_get_idx(route_jarr, json_array_idx);

                        senao_json_object_get_and_create_string(rep, route_jarr_info, "route", &route);

                        if ((json_array_idx + 1) < arraylen)
                            j+=sprintf(buf+j, "%s ", route);
                        else
                            j+=sprintf(buf+j, "%s", route);

                    }
                    strcpy(route_data.profile_name, profileName);
                    strcpy(route_data.route, buf);
                    api_set_vpn_route_section(route_data);
                }
                //=================route end===================//
            }
        }

        RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
    }
    else
    {
        RET_GEN_ERRORMSG(res, API_INVALID_DATA_TYPE, "JSON");
    }

}

int json_delete_all_vpn_profile(ResponseEntry *rep, char *query_str)
{
    ResponseStatus *res = rep->res;

    char buf[512] = {0},cmd[256] = {0};
    char *node = NULL, *_node = NULL;

    memset(buf, 0, sizeof(buf));
    sys_interact(buf, sizeof(buf), "foreach ipsec_profile");

    node = strtok_r(buf, "\n", &_node);
    while(node != NULL)
    {
        memset(cmd, 0, sizeof (cmd));
        sprintf(cmd, "uci delete ipsec_profile.%s", node);
        system(cmd);

        node =strtok_r(NULL, "\n", &_node);
    }

    //system("uci commit");

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}

int json_get_wifi_vpn_status(ResponseEntry *rep, struct json_object *jobj)
{
    ResponseStatus *res = rep->res;
    char buf[4096] = {0};

    sys_interact(buf, sizeof(buf), "ipsec statusall");

    json_object_object_add(jobj, "vpn_status", json_object_new_string(buf));

    RET_GEN_ERRORMSG(res, API_SUCCESS, NULL);
}
